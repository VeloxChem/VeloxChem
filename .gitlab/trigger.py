#!/usr/bin/env python3

import argparse
import json
import os
import re
from datetime import datetime
from pathlib import Path
from subprocess import run

from requests import post


def main():

    parser = argparse.ArgumentParser(
        description="Prepare JSON payload for HTTP request."
    )

    parser.add_argument(
        "--tarball",
        dest="tarball",
        action="store",
        type=str,
        required=True,
        help="location of tarball",
    )
    parser.add_argument(
        "--url",
        dest="url",
        action="store",
        type=str,
        required=True,
        help="URL of tarball",
    )
    # the commit description defaults to CI_COMMIT_DESCRIPTION
    parser.add_argument(
        "--commit",
        dest="commit",
        action="store",
        type=str,
        default=os.getenv("CI_COMMIT_DESCRIPTION", ""),
        help="commit description",
    )

    args = parser.parse_args()

    tarball = Path(args.tarball).resolve()

    # get recipe name from tarball
    recipe = tarball.name.split(".")[0]

    # get sha256 of tarball
    with Path(f"{args.tarball}.sha256").resolve().open("r") as f:
        sha256 = f.readline().strip().split()[0]

    # parse commit message, the configuration is expected in dict-like format
    msg = re.search(
        r"package\s*=\s*{(?P<content>.*)}", args.commit, re.MULTILINE | re.DOTALL
    )
    known_keys = ["channel", "label", "build", "version"]
    # create configuration dictionary, filter out unknown keys
    conf = (
        {
            m.group("key"): str(m.group("value"))
            for m in re.finditer(
                r"[\"\'](?P<key>\S+)[\"\']\s*:\s*[\"\'](?P<value>\S+)[\"\']",
                msg.group("content"),
                re.MULTILINE | re.DOTALL,
            )
            if m.group("key") in known_keys
        }
        if msg is not None
        else {}
    )
    if conf:
        print(f"Additional configuration from commit description:\n {conf}")
    else:
        print(f"No additional configuration from commit description")

    # read contents of __init__.py
    init_py = Path(__file__).parents[1] / "src/python/__init__.py"
    with init_py.open("r") as f:
        contents = f.read()

    version = ""
    regex = r"(?P<pre>__version__ = [\"\'])(?P<version>.*)(?P<post>[\"\'])"
    if "version" not in conf.keys():
        # get version from __init__.py
        ret = re.search(regex, contents)
        if ret is not None:
            # get predefined version
            version = ret.group("version")
    else:
        # we generate a patch to be applied before building the recipe
        # to fix the version of the package
        with init_py.open("w") as f:
            f.write(re.sub(regex, f"\\g<pre>{conf['version']}\\g<post>", contents))

    # append dictionary with information on deployment
    deploy = {
        "timestamp": datetime.now().astimezone().strftime("%A %Y-%m-%d %H:%M:%S %Z"),
        "author": os.getenv("GITLAB_USER_NAME", ""),
        "commit": os.getenv("CI_COMMIT_SHA", ""),
    }
    with init_py.open("a") as f:
        f.write(
            f"\n# autogenerated information on deployment\n__deployed__ = {json.dumps(deploy, indent=2, sort_keys=True)}\n"
        )

    # set permissions to 644 for all Python files in project
    _ = [
        _.chmod(0o644)
        for _ in (Path(__file__).parents[1] / "src/python").iterdir()
        if (_.is_file() and _.suffix == ".py")
    ]

    # call git diff
    p = run(
        ["git", "diff", str(init_py)], capture_output=True, check=True, encoding="ascii"
    )
    # the patch is in the stdout
    version_patch = p.stdout

    # inputs with defaults
    inputs = {
        "recipe": recipe,
        "url": args.url,
        "sha256": sha256,
        "version": version,
        "build": str(0),
        "channel": "veloxchem",
        "label": "main",
        "patch": version_patch,
    }
    # update inputs with configuration from commit message
    inputs.update(conf)

    # prepare payload
    payload = {
        "ref": "refs/heads/main",
        "inputs": inputs,
    }

    # get GitHub PAT
    gh_pat = os.getenv("GITHUB_PAT")
    r = post(
        "https://api.github.com/repos/ENCCS/meta-vlx/actions/workflows/deploy-cxx.yml/dispatches",
        auth=("robertodr", gh_pat),
        headers={"Accept": "application/vnd.github.v3+json"},
        data=json.dumps(payload),
    )

    print(f"POST request payload\n{payload}")
    if r.status_code == 204:
        print(f"POST request SUCCEEDED!")
    else:
        raise RuntimeError(f"POST request FAILED!\n{r.text}")


if __name__ == "__main__":
    main()
