import matplotlib.pyplot as plt
import numpy as np
import copy
import h5py
import sys
import math

# Purpose:
#
# This script takes HDF5-formatted output from a VeloxChem calculation of a
# system's first-order electric dipole response using the "pulsed response"
# functionality, and plots this response and the field in frequency domain,
# and plots the resulting first-order correction to the dipole moment and the
# time-domain representation of the field, optionally displaying this entire
# double plot in a window and/or saving it to a file.
#
# Usage:
#
# From the command line, execute as
#
# python3 pulsed_response_plot.py file_with_data.h5 [show=y/N] [save=Y/n]
# [dpi=n] [lw=0.8] [freq_max=1.0] [freq_units=au] [time_max=2000.0]
# [time_units=au] [save_to=pulsed_plot.pdf]
#
# where
#
# 'file_with_data.h5' is the name of the file containing the HDF5-formatted
# VeloxChem output.
#
# 'show' is an optional keyword whose permitted values are Y (yes) or n (no)
# and whose default value is n, denoting whether or not to display the
# resulting plot in a window on screen. The plot may then be resized and the
# changes introduced by that will carry over to the image saved by using
# the 'save=y' option, including scaling of axis tick labels and other such
# details.
#
# 'save' is an optional keyword whose permitted values are Y (yes) or n (no)
# and whose default value is Y, denoting whether or not to save the the
# resulting plot to the disk. Note that such saving can also be done manually
# from the display window whose decision to open is made with the 'show'
# keyword. Note also that any resizing carried out in the display window
# will affect an image generated by using the 'save' keyword. Unless the
# 'save_to' keyword is used, this image will be saved as the file
# 'pulsed_plot.pdf' in the folder from which pulsed_response_plot.py was run.
#
# 'dpi' is an optional keyword which whose value should be an integer (the
# default value is 240), specifying the resolution in dots per inch of the
# image of the plot to be saved to disk.
#
# 'lw' is an optional keyword whose value should be a number (the default
# value is 0.8), specifying the line thickness of the curves in the plot.
# Frequency-domain field curves will be plotted at half this linewidth.
#
# 'freq_max' is an optional keyword whose value should be a number, specifying
# the maximum frequency value (using the chosen units, where atomic units is
# the default) over which the data is plotted. The default value is 1.0 a.u.
# or appx. 27.21 eV.
#
# 'freq_units' is an optional keyword whose permitted values are 'au' or 'ev',
# specifying with respect to which units frequency-domain data is plotted. The
# default value is 'au' and that option will have this data plotted in atomic
# units of frequency. The option 'ev' will instead have this data plotted in
# units of electron volts.
#
# 'time_max' an optional keyword whose value should be a number, specifying
# the maximum time value (using the chosen units, where atomic units is the
# default) over which the data is plotted. The default value is 2000 a.u. or
# appx. 48.38 fs.
#
# 'time_units' is an optional keyword whose permitted values are 'au' or 'fs',
# specifying with respect to which units time-domain data is plotted. The
# default value is 'au' and that option will have this data plotted in atomic
# units of time. The option 'fs' will instead have this data plotted in units
# of femtoseconds.
#
# 'save_to' is an optional keyword which only has an effect if 'save' is not
# 'n', specifying the name of the file to which the image of the plot will be
# saved. If not specified, the default name of this file is 'pulsed_plot.pdf'
# with the same location as the folder from which pulsed_response_plot.py was
# run.
#
# Example usage:
#
# 1) The command
#
# python3 pulsed_response_plot.py water/pulsed.h5 show=Y dpi=300
# water/water_pulsed_plot.pdf
#
# will generate a plot from the VeloxChem pulsed-field response output stored
# in 'water/pulsed.h5', display that plot in a window on screen, then save the
# plot at a resolution of 300 DPI as water/water_pulsed_plot.pdf .
#
# 2) The command
#
# python3 pulsed_response_plot.py water/pulsed.h5 freq_units=ev time_units=fs
# time_max=23.0
#
# will generate a plot from the VeloxChem pulsed-field response output stored
# in 'water/pulsed.h5' and save it as pulsed_plot.pdf , using electron volts
# as unit for the frequency-domain part of the plot (where the maximum
# frequency for which data is plotted will be the default), and using
# femtoseconds as unit for the time-domain part of the plot, where the maximum
# time for which data is plotted will be 23.0 fs.
#
# The plot:
#
# The plot will contain two subplots:
#
# Subplot A (top) will display the real (red curve) and imaginary (blue curve)
# part of the frequency-domain first-order response (whose values are
# independent of the applied field) and the real part (black full curve) and
# absolute value (black dotted curve) of the frequency-domain strength of the
# applied field. The values associated with the former two curves are shown on
# the left-hand second axis, while the values associated with the latter two
# curves are shown on the right-hand second axis.
#
# Subplot B (bottom) will display the time-domain first-order response of the
# system to the applied field (i.e. this curve does depend on the applied
# field and the system-specific response) as a red curve (values on right-hand
# second axis) and the applied field (black curve, values on left-hand second
# axis).


# Mirror an array and pad it with zeroes
def mirror_and_zeropad(arr, zeropad):
    arr_inv = copy.copy(arr[1:][::-1])
    arr_inv = [np.conj(xv) for xv in arr_inv]
    arr = arr_inv + arr
    arr = zeropad + arr + zeropad
    return arr


# Get string representation of exponent for use in plotting
def get_txt_exp(x):
    if not (isinstance(x, int)):
        raise ValueError
        return
    if x == 0:
        return ''
    else:
        return r'$\times 10^{' + str(x) + '}$'


# Determine second axis limit data for plotting based on maximum absolute
# value (including plot "air")
def get_plot_ceil(v):

    ex = math.log10(v)
    exint = int(ex)

    if (v >= 1.0):
        r = 10.0**(ex - exint)
        return r, exint, get_txt_exp(exint)
    else:
        r = 10.0**(ex - exint + 1)
        return r, exint - 1, get_txt_exp(exint - 1)


def plot_pulsed_response(args, is_this_a_test=False):

    # Setting default values for command-line arguments
    show_plot = False
    save_plot = True
    plot_dpi = 240
    out_filename = 'pulsed_plot.pdf'
    freq_units = 'au'
    time_units = 'au'
    # Frequency-domain upper x-axis limit (in a.u.)
    freq_max = 1.0
    # Time-domain upper x-axis limit (in a.u.)
    time_max = 2000.0
    # Plot line thickness
    lw = 0.8

    # Non-command-line parameters
    # How much extra space (expressed as a factor) over max of abs(curve data)
    # to leave (1.0=no space)
    plot_air = 1.1

    # Physical parameter conversion factors
    # Hartree to eV
    hartree_to_ev = 27.211386246
    # Atomic units of time to femtoseconds
    autime_to_fs = 0.024188843265857

    # Logical arguments for coordinating potential scaling of units
    # Tells if any of these parameters were specified as non-default values
    freq_units_nd = False
    freq_max_nd = False
    time_units_nd = False
    time_max_nd = False

    # Names of plotting units
    freq_units_names = {'au': 'a.u.', 'ev': 'eV'}
    time_units_names = {'au': 'a.u.', 'fs': 'fs'}

    # Walking through command-line arguments
    if not (len(args) > 1):

        sys.exit('ERROR: Missing argument specifying input file')

    else:

        # Name of file containing HDF5 data
        inp_filename = str(args[1])

        # Going through optional other arguments
        if (len(args) > 2):

            rest_of_args = args[2:]

            # Counter, target for recognized arguments
            num_args_recogn = 0
            tgt_args_recogn = len(args[2:])

            # Show or don't show plot
            try:
                arg = [str(i).startswith('show=') for i in rest_of_args
                       ].index(True)

                if (str(rest_of_args[arg])[5].lower() == 'y'):
                    show_plot = True

                elif (str(rest_of_args[arg])[5].lower() == 'n'):
                    show_plot = False

                else:

                    err_str = "ERROR: Invalid keyword " + str(
                        rest_of_args[arg])[5] + " for keyword 'show'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            # Save or don't save plot to file
            try:
                arg = [str(i).startswith('save=') for i in rest_of_args
                       ].index(True)

                if (str(rest_of_args[arg])[5].lower() == 'y'):
                    save_plot = True

                elif (str(rest_of_args[arg])[5].lower() == 'n'):
                    save_plot = False

                else:
                    err_str = "ERROR: Invalid keyword" + str(
                        rest_of_args[arg])[5] + "for keyword 'save'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            # Resolution of plot image to be saved
            try:
                arg = [str(i).startswith('dpi=') for i in rest_of_args
                       ].index(True)

                try:
                    plot_dpi = int(str(rest_of_args[arg])[4:])

                except ValueError:

                    err_str = "ERROR: Invalid value" + str(
                        rest_of_args[arg])[4:] + "for keyword 'dpi'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            # Thickness of lines in plot curves
            try:
                arg = [str(i).startswith('lw=') for i in rest_of_args
                       ].index(True)

                try:
                    lw = float(str(rest_of_args[arg])[3:])

                except ValueError:

                    err_str = "ERROR: Invalid value" + str(
                        rest_of_args[arg])[3:] + "for keyword 'lw'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            # Name of output file to save plot image to
            try:
                arg = [str(i).startswith('save_to=') for i in rest_of_args
                       ].index(True)

                try:
                    out_filename = str(rest_of_args[arg])[8:]

                    if not (save_plot):
                        print(
                            'WARNING: Plot output filename was specified but it was also specified to not save plot image to file. Plot output filename keyword will be ineffectual.'
                               )

                except ValueError:
                    sys.exit("ERROR: Invalid value",
                             str(rest_of_args[arg])[4:],
                             "for keyword 'save_to'")

                num_args_recogn += 1

            except ValueError:
                pass

            # Maximum frequency value to plot
            try:
                arg = [str(i).startswith('freq_max=') for i in rest_of_args
                       ].index(True)

                try:
                    freq_max = float(str(rest_of_args[arg])[9:])
                    freq_max_nd = True

                except ValueError:

                    err_str = "ERROR: Invalid value" + str(
                        rest_of_args[arg])[9:] + "for keyword 'freq_max'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            # Choice of units of frequency values in plot
            try:
                arg = [str(i).startswith('freq_units=') for i in rest_of_args
                       ].index(True)

                if (str(rest_of_args[arg])[11:].lower() == 'au'):
                    freq_units = 'au'
                    freq_units_nd = True

                elif (str(rest_of_args[arg])[11:].lower() == 'ev'):
                    freq_units = 'ev'
                    freq_units_nd = True

                else:

                    err_str = "ERROR: Invalid keyword " + str(
                        rest_of_args[arg])[11:] + " for keyword 'freq_units'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            # Maximum time value to plot
            try:
                arg = [str(i).startswith('time_max=') for i in rest_of_args
                       ].index(True)

                try:
                    time_max = float(str(rest_of_args[arg])[9:])
                    time_max_nd = True

                except ValueError:

                    err_str = "ERROR: Invalid value" + str(
                        rest_of_args[arg])[9:] + "for keyword 'time_max'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            # Choice of units of time values in plot
            try:
                arg = [str(i).startswith('time_units=') for i in rest_of_args
                       ].index(True)

                if (str(rest_of_args[arg])[11:].lower() == 'au'):
                    time_units = 'au'
                    time_units_nd = True

                elif (str(rest_of_args[arg])[11:].lower() == 'fs'):
                    time_units = 'fs'
                    time_units_nd = True

                else:

                    err_str = "ERROR: Invalid keyword " + str(
                        rest_of_args[arg])[11:] + " for keyword 'time_units'"
                    sys.exit(err_str)

                num_args_recogn += 1

            except ValueError:
                pass

            if (not (num_args_recogn) == tgt_args_recogn):
                sys.exit(
                    'ERROR: ' + str(tgt_args_recogn - num_args_recogn) +
                    ' command-line argument(s) not recognized by parser. Please check input again.'
                         )

    # Potentially change value of plot maximum if units chosen as non-default
    # but max was default
    if (time_units_nd):
        if not (time_max_nd):
            if (time_units == 'fs'):
                time_max *= autime_to_fs

    if (freq_units_nd):
        if not (freq_max_nd):
            if (freq_units == 'ev'):
                freq_max *= hartree_to_ev

    # Get HDF5 data from file
    hf = h5py.File(inp_filename, 'r')

    # Find out if data is zero padded
    data_is_zeropadded = hf.get('zero_padded')

    # For now don't accept data which is not zero-padded
    if not (data_is_zeropadded[0]):
        sys.exit('ERROR: Expected zero-padded values for plotting')

    # Get frequency values over which field and response data is defined
    freqs = hf.get('frequencies')[()].tolist()

    # Get field frequency-domain amplitudes
    field_w = hf.get('amplitudes')[()].tolist()

    # Get xx, yy, and zz elements of first-order response tensor
    xdata = hf.get('xx')[()].tolist()
    ydata = hf.get('yy')[()].tolist()
    zdata = hf.get('zz')[()].tolist()

    # Make zero-padding list
    zeropad = [0.0] * 5000

    # Mirror, zero-pad, concatenate response data
    x_alphas = np.array(mirror_and_zeropad(xdata, zeropad))
    y_alphas = np.array(mirror_and_zeropad(ydata, zeropad))
    z_alphas = np.array(mirror_and_zeropad(zdata, zeropad))

    # Mirror, zero-pad, concatenate field amplitudes, store as array
    field_w_inv = copy.copy(field_w[1:][::-1])
    field_w_inv = [np.conj(xv) for xv in field_w_inv]
    field_w = field_w_inv + field_w
    field_w = np.array(zeropad + field_w + zeropad)

    # Make frequency bins for plotting
    dxfreq = abs(freqs[1] - freqs[0])
    dfreq = dxfreq * (len(x_alphas) - 1) / 2.
    xfreqs = np.array(np.linspace(-dfreq, dfreq, len(field_w), endpoint=True))

    # Generate time bins based on frequency bins
    w = xfreqs
    dw = xfreqs[1] - xfreqs[0]
    N = len(xfreqs)
    dt = 2. * np.pi / (N * dw)
    # FIXME Check N-1 vs N on next line
    t_end = ((N - 1) / 2) * dt
    t = np.linspace(-t_end, t_end, len(xfreqs), endpoint=True)

    # Rearrange time and frequency bins
    tshift = np.fft.ifftshift(
        t)  # Ordering is zero, then positive ascending, then negative ascending
    wshift = np.fft.ifftshift(
        w)  # Ordering is zero, then positive ascending, then negative ascending

    # Isotropic average of polarizability tensor
    alphas = 1. / 3. * (x_alphas + y_alphas + z_alphas)

    # Perform DFT on alpha rearranged into same order as tshift and wshift
    dipmom = []
    dipmom = np.fft.fft(np.fft.ifftshift(alphas * field_w))

    # Multiply by phase factor to get continuous FT
    dipmom *= dw * np.exp(-1.j * wshift[0] * tshift)
    dipmom_plot = np.fft.fftshift(dipmom)

    # Calculate the time series of the field
    field_t = []
    field_t = np.fft.fft(np.fft.ifftshift(field_w))
    field_t *= dw * np.exp(-1.j * wshift[0] * tshift)
    field_t_plot = np.fft.fftshift(field_t)

    # Scale x axis data if non-default units
    if (time_units_nd):
        if (time_units == 'fs'):
            t *= autime_to_fs
    if (freq_units_nd):
        if (freq_units == 'ev'):
            xfreqs *= hartree_to_ev

    # -------------------------------------------
    # 	Time-domain plot
    # -------------------------------------------
    # Initialize figure and axes
    fig1 = plt.figure(1, figsize=(10, 5))
    (ax21, ax11) = fig1.subplots(2, 1)
    ax12 = ax11.twinx()

    # Calculate various second axis plot limit data for time-domain response
    dipmax = np.max((np.abs(np.real(dipmom_plot))))
    dip_base, dip_exp, dip_str = get_plot_ceil(plot_air * dipmax)

    # Second axis plot limit data for time-domain field
    fieldmax = np.max((np.abs(np.real(field_t_plot))))
    field_base, field_exp, field_str = get_plot_ceil(plot_air * fieldmax)

    # Plotting time-domain response
    dipmom_t_real_plot = np.real(dipmom_plot) * (10.0**(-1.0 * dip_exp))

    leg_t_real, = ax12.plot(
        t, dipmom_t_real_plot, color='r', linewidth=lw, label='real_t')

    # Test if imaginary data is always zero (or close to it)
    imag_test = np.imag(dipmom_plot)
    zero_thres = 1.0e-15
    for i in range(len(imag_test)):
        if not (abs(imag_test[i]) < zero_thres):
            err_str = 'ERROR: Imaginary part of time-domain response was expected to be zero (or practically zero) but value ' + str(
                i + 1) + ' was ' + str(imag_test[i])
            sys.exit(err_str)

    # Plotting time-domain field
    field_t_real_plot = np.real(field_t_plot) * (10.0**(-1.0 * field_exp))

    leg_t_field, = ax11.plot(
        t, field_t_real_plot, color='k', linewidth=lw, label='f_t')

    # Adding labels
    ax11.text(0.01, 1.01, field_str, transform=ax11.transAxes)
    ax11.text(0.94, 1.01, dip_str, transform=ax11.transAxes)
    ax11.set_ylabel(r'F(t) [a.u.]')
    ax12.set_ylabel(r'$\overline{\mu}^{(1)}$(t) [a.u.]')

    # Set the plot limits
    ax11.set_ylim([-field_base, field_base])
    ax12.set_ylim([-dip_base, dip_base])
    ax11.set_xlim([0.0, time_max])

    # Add legend
    ax11.legend([leg_t_real, leg_t_field],
                [r'$\overline{\mu}^{(1)}$(t)', r'F(t)'],
                frameon=True)

    # -------------------------------------------
    # 	Frequency-domain plot
    # -------------------------------------------
    # Initialize axes
    ax22 = ax21.twinx()

    # Second axis plot limit data for frequency-domain response
    alphamax = max(
        np.max((np.abs(np.real(alphas)))), np.max((np.abs(np.imag(alphas)))))
    alpha_base, alpha_exp, alpha_str = get_plot_ceil(plot_air * alphamax)

    # Second axis plot limit data for frequency-domain field
    fieldmax = np.max((np.abs(field_w)))
    field_base, field_exp, field_str = get_plot_ceil(plot_air * fieldmax)

    # Plotting frequency-domain response
    alpha_real_plot = np.real(alphas) * (10.0**(-1.0 * alpha_exp))
    alpha_imag_plot = np.imag(alphas) * (10.0**(-1.0 * alpha_exp))

    leg_real, = ax22.plot(
        xfreqs, alpha_real_plot, color='b', linewidth=lw, label='real_w')
    leg_imag, = ax22.plot(
        xfreqs,
        alpha_imag_plot,
        color='b',
        linestyle='--',
        linewidth=lw,
        label='imag_w')

    # Plotting frequency-domain field
    field_w_real_plot = np.real(field_w) * (10.0**(-1.0 * field_exp))
    field_w_env_plot = np.abs(field_w) * (10.0**(-1.0 * field_exp))

    leg_field, = ax21.plot(
        xfreqs, field_w_real_plot, color='k', linewidth=lw * 0.5, label='f_w')
    ax21.plot(
        xfreqs, field_w_env_plot, color='k', linestyle=':', linewidth=lw * 0.5)

    # Add label
    ax21.text(0.94, 1.01, alpha_str, transform=ax21.transAxes)
    ax21.text(0.01, 1.01, field_str, transform=ax21.transAxes)

    # Set the plot limits
    ax22.set_ylim([-alpha_base, alpha_base])
    ax21.set_ylim([-field_base, field_base])
    ax21.set_xlim([0.0, freq_max])

    # Add legend
    ax21.legend([leg_real, leg_imag, leg_field], [
        r'Re[$\overline{\alpha}$($\omega$)]',
        r'Im[$\overline{\alpha}$($\omega$)]', r'F$_{\omega}(\omega)$'
    ],
                frameon=True)

    # ---------------------------------------------
    #   Save the plot
    # ---------------------------------------------
    ax21.set_ylabel(r'F$_{\omega}(\omega)$ [a.u.]')
    ax22.set_ylabel(r'$\overline{\alpha}$($\omega$) [a.u.]')
    ax21.set_xlabel('Frequency [' + freq_units_names[freq_units] + ']')
    ax11.set_xlabel('Time [' + time_units_names[time_units] + ']')

    # Adjust plots
    plt.subplots_adjust(hspace=0.34, top=0.96)

    # Show plot if requested
    if (show_plot):
        plt.show()

    # Save plot if requested
    if (save_plot):
        fig1.savefig(out_filename, dpi=plot_dpi)

    # Close plot
    plt.close(fig1)

    # If this run was done for testing purposes, return various data to be
    # tested
    if (is_this_a_test):
        return xfreqs, alpha_real_plot, alpha_imag_plot, field_w_real_plot, field_w_env_plot, t, dipmom_t_real_plot, field_t_real_plot

    else:
        return True


if __name__ == "__main__":

    status = plot_pulsed_response(sys.argv)

    if not (status):
        sys.exit(
            'ERROR: Pulsed response plotting did not complete successfully')
