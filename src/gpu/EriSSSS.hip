//
//                              VELOXCHEM
//         ----------------------------------------------------
//                     An Electronic Structure Code
//
//  Copyright © 2018-2023 by VeloxChem developers. All rights reserved.
//  Contact: https://veloxchem.org/contact
//
//  SPDX-License-Identifier: LGPL-3.0-or-later
//
//  This file is part of VeloxChem.
//
//  VeloxChem is free software: you can redistribute it and/or modify it under
//  the terms of the GNU Lesser General Public License as published by the Free
//  Software Foundation, either version 3 of the License, or (at your option)
//  any later version.
//
//  VeloxChem is distributed in the hope that it will be useful, but WITHOUT
//  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
//  License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with VeloxChem. If not, see <https://www.gnu.org/licenses/>.

#include <hip/hip_runtime.h>

#include <algorithm>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <string>
#include <tuple>
#include <vector>

#include "BoysFuncTable.hpp"
#include "EriSSSS.hpp"
#include "ErrorHandler.hpp"
#include "GtoFunc.hpp"
#include "GtoInfo.hpp"
#include "MathConst.hpp"
#include "MathFunc.hpp"
#include "MatrixFunc.hpp"
#include "MpiFunc.hpp"
#include "MultiTimer.hpp"
#include "StringFormat.hpp"

#define TILE_DIM 16

#define MATH_CONST_PI 3.14159265358979323846

#define MATH_CONST_HALF_SQRT_PI 0.88622692545275794096

#define hipSafe(e)                                                                                                        \
    {                                                                                                                     \
        hipError_t err = (e);                                                                                             \
        if (err != hipSuccess)                                                                                            \
        {                                                                                                                 \
            std::cerr << "CUDA error in " << __FILE__ << ":" << __LINE__ << ": " << hipGetErrorString(err) << std::endl;  \
            std::exit(EXIT_FAILURE);                                                                                      \
        }                                                                                                                 \
    }

namespace gpu {  // gpu namespace

__device__ void
computeBoysFunction(double* values, const double fa, const uint32_t N, const double* bf_table, const double* ft)
{
    // Note: 847 = 121 * 7
    const double* bf_data = bf_table + N * 847;

    uint32_t pnt = (fa > 1.0e5) ? 1000000 : static_cast<uint32_t>(10.0 * fa + 0.5);

    if (pnt < 121)
    {
        const double w = fa - 0.1 * pnt;

        const double w2 = w * w;

        const double w4 = w2 * w2;

        values[N] = bf_data[pnt * 7 + 0] + bf_data[pnt * 7 + 1] * w + bf_data[pnt * 7 + 2] * w2 + bf_data[pnt * 7 + 3] * w2 * w

                    + bf_data[pnt * 7 + 4] * w4 + bf_data[pnt * 7 + 5] * w4 * w + bf_data[pnt * 7 + 6] * w4 * w2;

        const double f2a = fa + fa;

        const double fx = std::exp(-fa);

        for (uint32_t j = 0; j < N; j++)
        {
            values[N - j - 1] = ft[N - j - 1] * (f2a * values[N - j] + fx);
        }
    }
    else
    {
        const double fia = 1.0 / fa;

        double pf = 0.5 * fia;

        values[0] = MATH_CONST_HALF_SQRT_PI * std::sqrt(fia);

        if (pnt < 921)
        {
            const double fia2 = fia * fia;

            const double f = 0.4999489092 * fia - 0.2473631686 * fia2 + 0.3211809090 * fia2 * fia - 0.3811559346 * fia2 * fia2;

            const double fx = std::exp(-fa);

            values[0] -= f * fx;

            const double rterm = pf * fx;

            for (uint32_t j = 1; j <= N; j++)
            {
                values[j] = pf * values[j - 1] - rterm;

                pf += fia;
            }
        }
        else
        {
            for (uint32_t j = 1; j <= N; j++)
            {
                values[j] = pf * values[j - 1];

                pf += fia;
            }
        }
    }
}

__global__ void
cudaFockJ(double*         mat_J,
          const double*   s_prim_info,
          const uint32_t  s_prim_count,
          const double    max_D,
          const double*   mat_D,
          const double*   mat_Q,
          const uint32_t* first_inds,
          const uint32_t* second_inds,
          const uint32_t  ss_prim_pair_count,
          const double*   boys_func_table,
          const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (ss_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < ss_prim_pair_count) && (ij < ss_prim_pair_count) && (std::fabs(mat_Q[ij] * mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = first_inds[ij];
            const auto j = second_inds[ij];

            const auto k = first_inds[kl];
            const auto l = second_inds[kl];

            const auto a_i = s_prim_info[i + s_prim_count * 0];
            const auto c_i = s_prim_info[i + s_prim_count * 1];
            const auto x_i = s_prim_info[i + s_prim_count * 2];
            const auto y_i = s_prim_info[i + s_prim_count * 3];
            const auto z_i = s_prim_info[i + s_prim_count * 4];

            const auto a_j = s_prim_info[j + s_prim_count * 0];
            const auto c_j = s_prim_info[j + s_prim_count * 1];
            const auto x_j = s_prim_info[j + s_prim_count * 2];
            const auto y_j = s_prim_info[j + s_prim_count * 3];
            const auto z_j = s_prim_info[j + s_prim_count * 4];

            const auto a_k = s_prim_info[k + s_prim_count * 0];
            const auto c_k = s_prim_info[k + s_prim_count * 1];
            const auto x_k = s_prim_info[k + s_prim_count * 2];
            const auto y_k = s_prim_info[k + s_prim_count * 3];
            const auto z_k = s_prim_info[k + s_prim_count * 4];

            const auto a_l = s_prim_info[l + s_prim_count * 0];
            const auto c_l = s_prim_info[l + s_prim_count * 1];
            const auto x_l = s_prim_info[l + s_prim_count * 2];
            const auto y_l = s_prim_info[l + s_prim_count * 3];
            const auto z_l = s_prim_info[l + s_prim_count * 4];

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            const auto x_PQ = (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j);
            const auto y_PQ = (a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j);
            const auto z_PQ = (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j);

            const auto r2_PQ = x_PQ * x_PQ + y_PQ * y_PQ + z_PQ * z_PQ;

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            const auto t = (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ;

            double F0_t;

            gpu::computeBoysFunction(&F0_t, t, 0, boys_func_table, boys_func_ft);

            const auto S_ij = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);
            const auto S_kl = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = Lambda * S_ij * S_kl * F0_t * mat_D[kl] * (k == l ? 1.0 : 2.0);
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < ss_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockSSSP(double*         mat_J,
                       const double*   s_prim_info,
                       const uint32_t  s_prim_count,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   sp_mat_D,
                       const double*   ss_mat_Q,
                       const double*   sp_mat_Q,
                       const uint32_t* ss_first_inds,
                       const uint32_t* ss_second_inds,
                       const uint32_t  ss_prim_pair_count,
                       const uint32_t* sp_first_inds,
                       const uint32_t* sp_second_inds,
                       const uint32_t  sp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (sp_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < sp_prim_pair_count) && (ij < ss_prim_pair_count) && (std::fabs(ss_mat_Q[ij] * sp_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = ss_first_inds[ij];
            const auto j = ss_second_inds[ij];

            const auto k = sp_first_inds[kl];
            const auto l = sp_second_inds[kl];

            const auto a_i = s_prim_info[i + s_prim_count * 0];
            const auto c_i = s_prim_info[i + s_prim_count * 1];
            const auto x_i = s_prim_info[i + s_prim_count * 2];
            const auto y_i = s_prim_info[i + s_prim_count * 3];
            const auto z_i = s_prim_info[i + s_prim_count * 4];

            const auto a_j = s_prim_info[j + s_prim_count * 0];
            const auto c_j = s_prim_info[j + s_prim_count * 1];
            const auto x_j = s_prim_info[j + s_prim_count * 2];
            const auto y_j = s_prim_info[j + s_prim_count * 3];
            const auto z_j = s_prim_info[j + s_prim_count * 4];

            const auto a_k = s_prim_info[k + s_prim_count * 0];
            const auto c_k = s_prim_info[k + s_prim_count * 1];
            const auto x_k = s_prim_info[k + s_prim_count * 2];
            const auto y_k = s_prim_info[k + s_prim_count * 3];
            const auto z_k = s_prim_info[k + s_prim_count * 4];

            const auto a_l = p_prim_info[l / 3 + p_prim_count * 0];
            const auto c_l = p_prim_info[l / 3 + p_prim_count * 1];
            const auto x_l = p_prim_info[l / 3 + p_prim_count * 2];
            const auto y_l = p_prim_info[l / 3 + p_prim_count * 3];
            const auto z_l = p_prim_info[l / 3 + p_prim_count * 4];

            const auto l_cart = l % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F1_t[2];

            gpu::computeBoysFunction(F1_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 1, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);

            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rkl[3] = {y_l - y_k, z_l - z_k, x_l - x_k};

            const auto S_kl_01 = -(a_k / (a_k + a_l)) * rkl[l_cart] * S_kl_00;

            const double eri_ijkl = Lambda * (

                    S_ij_00 * S_kl_01 * F1_t[0] +

                    S_ij_00 * S_kl_00 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[l_cart] * F1_t[1]

                    );

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * sp_mat_D[kl] * 2.0;
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < ss_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockSSPP(double*         mat_J,
                       const double*   s_prim_info,
                       const uint32_t  s_prim_count,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   pp_mat_D,
                       const double*   ss_mat_Q,
                       const double*   pp_mat_Q,
                       const uint32_t* ss_first_inds,
                       const uint32_t* ss_second_inds,
                       const uint32_t  ss_prim_pair_count,
                       const uint32_t* pp_first_inds,
                       const uint32_t* pp_second_inds,
                       const uint32_t  pp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (pp_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < pp_prim_pair_count) && (ij < ss_prim_pair_count) && (std::fabs(ss_mat_Q[ij] * pp_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = ss_first_inds[ij];
            const auto j = ss_second_inds[ij];

            const auto k = pp_first_inds[kl];
            const auto l = pp_second_inds[kl];

            const auto a_i = s_prim_info[i + s_prim_count * 0];
            const auto c_i = s_prim_info[i + s_prim_count * 1];
            const auto x_i = s_prim_info[i + s_prim_count * 2];
            const auto y_i = s_prim_info[i + s_prim_count * 3];
            const auto z_i = s_prim_info[i + s_prim_count * 4];

            const auto a_j = s_prim_info[j + s_prim_count * 0];
            const auto c_j = s_prim_info[j + s_prim_count * 1];
            const auto x_j = s_prim_info[j + s_prim_count * 2];
            const auto y_j = s_prim_info[j + s_prim_count * 3];
            const auto z_j = s_prim_info[j + s_prim_count * 4];

            const auto a_k = p_prim_info[k / 3 + p_prim_count * 0];
            const auto c_k = p_prim_info[k / 3 + p_prim_count * 1];
            const auto x_k = p_prim_info[k / 3 + p_prim_count * 2];
            const auto y_k = p_prim_info[k / 3 + p_prim_count * 3];
            const auto z_k = p_prim_info[k / 3 + p_prim_count * 4];

            const auto a_l = p_prim_info[l / 3 + p_prim_count * 0];
            const auto c_l = p_prim_info[l / 3 + p_prim_count * 1];
            const auto x_l = p_prim_info[l / 3 + p_prim_count * 2];
            const auto y_l = p_prim_info[l / 3 + p_prim_count * 3];
            const auto z_l = p_prim_info[l / 3 + p_prim_count * 4];

            const auto k_cart = k % 3;
            const auto l_cart = l % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F2_t[3];

            gpu::computeBoysFunction(F2_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 2, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);

            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};

            const double rkl[3] = {y_l - y_k, z_l - z_k, x_l - x_k};

            const auto S_kl_10 = (a_l / (a_k + a_l)) * rkl[k_cart] * S_kl_00;

            const auto S_kl_01 = -(a_k / (a_k + a_l)) * rkl[l_cart] * S_kl_00;

            const auto S_kl_11 = (

                    (k_cart == l_cart ? 1.0 : 0.0) * (0.5 / (a_k + a_l)) +

                    (a_k * a_l / ((a_k + a_l) * (a_k + a_l))) * (-rkl[k_cart]) * rkl[l_cart]

                    ) * S_kl_00;

            const double eri_ijkl = Lambda * (

                    S_ij_00 * S_kl_11 * F2_t[0] +

                    S_ij_00 * S_kl_10 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[l_cart] * F2_t[1] +

                    S_ij_00 * S_kl_01 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[k_cart] * F2_t[1] +

                    S_ij_00 * S_kl_00 * ((a_i + a_j) / (a_i + a_j + a_k + a_l)) * (

                        ((a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[k_cart] * rPQ[l_cart] * F2_t[2] -

                        (k_cart == l_cart ? 1.0 : 0.0) * (0.5 / (a_k + a_l)) * F2_t[1]

                    ));

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * pp_mat_D[kl] * (k == l ? 1.0 : 2.0);
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < ss_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockPPSS(double*         mat_J,
                       const double*   s_prim_info,
                       const uint32_t  s_prim_count,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   ss_mat_D,
                       const double*   ss_mat_Q,
                       const double*   pp_mat_Q,
                       const uint32_t* ss_first_inds,
                       const uint32_t* ss_second_inds,
                       const uint32_t  ss_prim_pair_count,
                       const uint32_t* pp_first_inds,
                       const uint32_t* pp_second_inds,
                       const uint32_t  pp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (ss_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < ss_prim_pair_count) && (ij < pp_prim_pair_count) && (std::fabs(pp_mat_Q[ij] * ss_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = pp_first_inds[ij];
            const auto j = pp_second_inds[ij];

            const auto k = ss_first_inds[kl];
            const auto l = ss_second_inds[kl];

            const auto a_i = p_prim_info[i / 3 + p_prim_count * 0];
            const auto c_i = p_prim_info[i / 3 + p_prim_count * 1];
            const auto x_i = p_prim_info[i / 3 + p_prim_count * 2];
            const auto y_i = p_prim_info[i / 3 + p_prim_count * 3];
            const auto z_i = p_prim_info[i / 3 + p_prim_count * 4];

            const auto a_j = p_prim_info[j / 3 + p_prim_count * 0];
            const auto c_j = p_prim_info[j / 3 + p_prim_count * 1];
            const auto x_j = p_prim_info[j / 3 + p_prim_count * 2];
            const auto y_j = p_prim_info[j / 3 + p_prim_count * 3];
            const auto z_j = p_prim_info[j / 3 + p_prim_count * 4];

            const auto a_k = s_prim_info[k + s_prim_count * 0];
            const auto c_k = s_prim_info[k + s_prim_count * 1];
            const auto x_k = s_prim_info[k + s_prim_count * 2];
            const auto y_k = s_prim_info[k + s_prim_count * 3];
            const auto z_k = s_prim_info[k + s_prim_count * 4];

            const auto a_l = s_prim_info[l + s_prim_count * 0];
            const auto c_l = s_prim_info[l + s_prim_count * 1];
            const auto x_l = s_prim_info[l + s_prim_count * 2];
            const auto y_l = s_prim_info[l + s_prim_count * 3];
            const auto z_l = s_prim_info[l + s_prim_count * 4];

            const auto i_cart = i % 3;
            const auto j_cart = j % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F2_t[3];

            gpu::computeBoysFunction(F2_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 2, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);

            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};

            const double rkl[3] = {y_l - y_k, z_l - z_k, x_l - x_k};

            const auto S_ij_10 = (a_j / (a_i + a_j)) * rij[i_cart] * S_ij_00;

            const auto S_ij_01 = -(a_i / (a_i + a_j)) * rij[j_cart] * S_ij_00;

            const auto S_ij_11 = (

                    (i_cart == j_cart ? 1.0 : 0.0) * (0.5 / (a_i + a_j)) +

                    (a_i * a_j / ((a_i + a_j) * (a_i + a_j))) * (-rij[i_cart]) * rij[j_cart]

                    ) * S_ij_00;

            const double eri_ijkl = Lambda * (

                    S_kl_00 * S_ij_11 * F2_t[0] +

                    S_kl_00 * S_ij_10 * ((a_k + a_l) / (a_k + a_l + a_i + a_j)) * rPQ[j_cart] * F2_t[1] +

                    S_kl_00 * S_ij_01 * ((a_k + a_l) / (a_k + a_l + a_i + a_j)) * rPQ[i_cart] * F2_t[1] +

                    S_kl_00 * S_ij_00 * ((a_k + a_l) / (a_k + a_l + a_i + a_j)) * (

                        ((a_k + a_l) / (a_k + a_l + a_i + a_j)) * rPQ[i_cart] * rPQ[j_cart] * F2_t[2] -

                        (i_cart == j_cart ? 1.0 : 0.0) * (0.5 / (a_i + a_j)) * F2_t[1]

                    ));

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * ss_mat_D[kl] * (k == l ? 1.0 : 2.0);
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < pp_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockSPSS(double*         mat_J,
                       const double*   s_prim_info,
                       const uint32_t  s_prim_count,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   ss_mat_D,
                       const double*   ss_mat_Q,
                       const double*   sp_mat_Q,
                       const uint32_t* ss_first_inds,
                       const uint32_t* ss_second_inds,
                       const uint32_t  ss_prim_pair_count,
                       const uint32_t* sp_first_inds,
                       const uint32_t* sp_second_inds,
                       const uint32_t  sp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (ss_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < ss_prim_pair_count) && (ij < sp_prim_pair_count) && (std::fabs(sp_mat_Q[ij] * ss_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = sp_first_inds[ij];
            const auto j = sp_second_inds[ij];

            const auto k = ss_first_inds[kl];
            const auto l = ss_second_inds[kl];

            const auto a_i = s_prim_info[i + s_prim_count * 0];
            const auto c_i = s_prim_info[i + s_prim_count * 1];
            const auto x_i = s_prim_info[i + s_prim_count * 2];
            const auto y_i = s_prim_info[i + s_prim_count * 3];
            const auto z_i = s_prim_info[i + s_prim_count * 4];

            const auto a_j = p_prim_info[j / 3 + p_prim_count * 0];
            const auto c_j = p_prim_info[j / 3 + p_prim_count * 1];
            const auto x_j = p_prim_info[j / 3 + p_prim_count * 2];
            const auto y_j = p_prim_info[j / 3 + p_prim_count * 3];
            const auto z_j = p_prim_info[j / 3 + p_prim_count * 4];

            const auto a_k = s_prim_info[k + s_prim_count * 0];
            const auto c_k = s_prim_info[k + s_prim_count * 1];
            const auto x_k = s_prim_info[k + s_prim_count * 2];
            const auto y_k = s_prim_info[k + s_prim_count * 3];
            const auto z_k = s_prim_info[k + s_prim_count * 4];

            const auto a_l = s_prim_info[l + s_prim_count * 0];
            const auto c_l = s_prim_info[l + s_prim_count * 1];
            const auto x_l = s_prim_info[l + s_prim_count * 2];
            const auto y_l = s_prim_info[l + s_prim_count * 3];
            const auto z_l = s_prim_info[l + s_prim_count * 4];

            const auto j_cart = j % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F1_t[2];

            gpu::computeBoysFunction(F1_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 1, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);

            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};

            const auto S_ij_01 = -(a_i / (a_i + a_j)) * rij[j_cart] * S_ij_00;

            const double eri_ijkl = Lambda * (

                    S_ij_01 * S_kl_00 * F1_t[0] +

                    S_ij_00 * S_kl_00 * ((a_k + a_l) / (a_i + a_j + a_k + a_l)) * rPQ[j_cart] * F1_t[1]

                    );

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * ss_mat_D[kl] * (k == l ? 1.0 : 2.0);
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < sp_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockSPSP(double*         mat_J,
                       const double*   s_prim_info,
                       const uint32_t  s_prim_count,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   sp_mat_D,
                       const double*   sp_mat_Q,
                       const uint32_t* sp_first_inds,
                       const uint32_t* sp_second_inds,
                       const uint32_t  sp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (sp_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < sp_prim_pair_count) && (ij < sp_prim_pair_count) && (std::fabs(sp_mat_Q[ij] * sp_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = sp_first_inds[ij];
            const auto j = sp_second_inds[ij];

            const auto k = sp_first_inds[kl];
            const auto l = sp_second_inds[kl];

            const auto a_i = s_prim_info[i + s_prim_count * 0];
            const auto c_i = s_prim_info[i + s_prim_count * 1];
            const auto x_i = s_prim_info[i + s_prim_count * 2];
            const auto y_i = s_prim_info[i + s_prim_count * 3];
            const auto z_i = s_prim_info[i + s_prim_count * 4];

            const auto a_j = p_prim_info[j / 3 + p_prim_count * 0];
            const auto c_j = p_prim_info[j / 3 + p_prim_count * 1];
            const auto x_j = p_prim_info[j / 3 + p_prim_count * 2];
            const auto y_j = p_prim_info[j / 3 + p_prim_count * 3];
            const auto z_j = p_prim_info[j / 3 + p_prim_count * 4];

            const auto a_k = s_prim_info[k + s_prim_count * 0];
            const auto c_k = s_prim_info[k + s_prim_count * 1];
            const auto x_k = s_prim_info[k + s_prim_count * 2];
            const auto y_k = s_prim_info[k + s_prim_count * 3];
            const auto z_k = s_prim_info[k + s_prim_count * 4];

            const auto a_l = p_prim_info[l / 3 + p_prim_count * 0];
            const auto c_l = p_prim_info[l / 3 + p_prim_count * 1];
            const auto x_l = p_prim_info[l / 3 + p_prim_count * 2];
            const auto y_l = p_prim_info[l / 3 + p_prim_count * 3];
            const auto z_l = p_prim_info[l / 3 + p_prim_count * 4];

            const auto j_cart = j % 3;
            const auto l_cart = l % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F2_t[3];

            gpu::computeBoysFunction(F2_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 2, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);
            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};
            const double rkl[3] = {y_l - y_k, z_l - z_k, x_l - x_k};

            const auto S_ij_01 = -(a_i / (a_i + a_j)) * rij[j_cart] * S_ij_00;
            const auto S_kl_01 = -(a_k / (a_k + a_l)) * rkl[l_cart] * S_kl_00;

            const double eri_ijkl = Lambda * (

                    S_ij_01 * S_kl_01 * F2_t[0] +

                    S_ij_01 * S_kl_00 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[l_cart] * F2_t[1] +

                    S_ij_00 * S_kl_01 * ((a_k + a_l) / (a_i + a_j + a_k + a_l)) * rPQ[j_cart] * F2_t[1] +

                    S_ij_00 * S_kl_00 / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[j_cart]) * rPQ[l_cart] * F2_t[2] +

                        (j_cart == l_cart ? 1.0 : 0.0) * 0.5 * F2_t[1]

                    ));

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * sp_mat_D[kl] * 2.0;
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < sp_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockSPPP(double*         mat_J,
                       const double*   s_prim_info,
                       const uint32_t  s_prim_count,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   pp_mat_D,
                       const double*   sp_mat_Q,
                       const double*   pp_mat_Q,
                       const uint32_t* sp_first_inds,
                       const uint32_t* sp_second_inds,
                       const uint32_t  sp_prim_pair_count,
                       const uint32_t* pp_first_inds,
                       const uint32_t* pp_second_inds,
                       const uint32_t  pp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (pp_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < pp_prim_pair_count) && (ij < sp_prim_pair_count) && (std::fabs(sp_mat_Q[ij] * pp_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = sp_first_inds[ij];
            const auto j = sp_second_inds[ij];

            const auto k = pp_first_inds[kl];
            const auto l = pp_second_inds[kl];

            const auto a_i = s_prim_info[i + s_prim_count * 0];
            const auto c_i = s_prim_info[i + s_prim_count * 1];
            const auto x_i = s_prim_info[i + s_prim_count * 2];
            const auto y_i = s_prim_info[i + s_prim_count * 3];
            const auto z_i = s_prim_info[i + s_prim_count * 4];

            const auto a_j = p_prim_info[j / 3 + p_prim_count * 0];
            const auto c_j = p_prim_info[j / 3 + p_prim_count * 1];
            const auto x_j = p_prim_info[j / 3 + p_prim_count * 2];
            const auto y_j = p_prim_info[j / 3 + p_prim_count * 3];
            const auto z_j = p_prim_info[j / 3 + p_prim_count * 4];

            const auto a_k = p_prim_info[k / 3 + p_prim_count * 0];
            const auto c_k = p_prim_info[k / 3 + p_prim_count * 1];
            const auto x_k = p_prim_info[k / 3 + p_prim_count * 2];
            const auto y_k = p_prim_info[k / 3 + p_prim_count * 3];
            const auto z_k = p_prim_info[k / 3 + p_prim_count * 4];

            const auto a_l = p_prim_info[l / 3 + p_prim_count * 0];
            const auto c_l = p_prim_info[l / 3 + p_prim_count * 1];
            const auto x_l = p_prim_info[l / 3 + p_prim_count * 2];
            const auto y_l = p_prim_info[l / 3 + p_prim_count * 3];
            const auto z_l = p_prim_info[l / 3 + p_prim_count * 4];

            const auto j_cart = j % 3;
            const auto k_cart = k % 3;
            const auto l_cart = l % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F3_t[4];

            gpu::computeBoysFunction(F3_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 3, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);
            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};
            const double rkl[3] = {y_l - y_k, z_l - z_k, x_l - x_k};

            const auto S_ij_01 = -(a_i / (a_i + a_j)) * rij[j_cart] * S_ij_00;

            const auto S_kl_10 = (a_l / (a_k + a_l)) * rkl[k_cart] * S_kl_00;
            const auto S_kl_01 = -(a_k / (a_k + a_l)) * rkl[l_cart] * S_kl_00;

            const auto S_kl_11 = (

                    (k_cart == l_cart ? 1.0 : 0.0) * (0.5 / (a_k + a_l)) +

                    (a_k * a_l / ((a_k + a_l) * (a_k + a_l))) * (-rkl[k_cart]) * rkl[l_cart]

                    ) * S_kl_00;

            const double eri_ijkl = Lambda * (

                    S_ij_01 * S_kl_11 * F3_t[0] +

                    S_ij_00 * S_kl_11 * ((a_k + a_l) / (a_i + a_j + a_k + a_l)) * rPQ[j_cart] * F3_t[1] +

                    S_ij_01 * S_kl_01 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[k_cart] * F3_t[1] +

                    S_ij_00 * S_kl_01 / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[j_cart]) * rPQ[k_cart] * F3_t[2] +

                        (j_cart == k_cart ? 1.0 : 0.0) * 0.5 * F3_t[1]

                    ) +

                    S_ij_01 * S_kl_10 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[l_cart] * F3_t[1] +

                    S_ij_00 * S_kl_10 / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[j_cart]) * rPQ[l_cart] * F3_t[2] +

                        (j_cart == l_cart ? 1.0 : 0.0) * 0.5 * F3_t[1]

                    ) +

                    S_ij_01 * S_kl_00 * (a_i + a_j) / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) / (a_i + a_j + a_k + a_l) * rPQ[k_cart] * rPQ[l_cart] * F3_t[2] -

                        (k_cart == l_cart ? 1.0 : 0.0) * 0.5 / (a_k + a_l) * F3_t[1]

                    ) +

                    S_ij_00 * S_kl_00 * (-(a_i + a_j)) / ((a_i + a_j + a_k + a_l) * (a_i + a_j + a_k + a_l)) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[j_cart]) * rPQ[k_cart] * rPQ[l_cart] * F3_t[3] -

                        ((j_cart == k_cart ? 1.0 : 0.0) * (-rPQ[l_cart]) + 
                         (j_cart == l_cart ? 1.0 : 0.0) * (-rPQ[k_cart]) +
                         (k_cart == l_cart ? 1.0 : 0.0) * (-rPQ[j_cart])) * 0.5 * F3_t[2]

                    ));

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * pp_mat_D[kl] * (k == l ? 1.0 : 2.0);
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < sp_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockPPSP(double*         mat_J,
                       const double*   s_prim_info,
                       const uint32_t  s_prim_count,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   sp_mat_D,
                       const double*   sp_mat_Q,
                       const double*   pp_mat_Q,
                       const uint32_t* sp_first_inds,
                       const uint32_t* sp_second_inds,
                       const uint32_t  sp_prim_pair_count,
                       const uint32_t* pp_first_inds,
                       const uint32_t* pp_second_inds,
                       const uint32_t  pp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (sp_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < sp_prim_pair_count) && (ij < pp_prim_pair_count) && (std::fabs(pp_mat_Q[ij] * sp_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = pp_first_inds[ij];
            const auto j = pp_second_inds[ij];

            const auto k = sp_first_inds[kl];
            const auto l = sp_second_inds[kl];

            const auto a_i = p_prim_info[i / 3 + p_prim_count * 0];
            const auto c_i = p_prim_info[i / 3 + p_prim_count * 1];
            const auto x_i = p_prim_info[i / 3 + p_prim_count * 2];
            const auto y_i = p_prim_info[i / 3 + p_prim_count * 3];
            const auto z_i = p_prim_info[i / 3 + p_prim_count * 4];

            const auto a_j = p_prim_info[j / 3 + p_prim_count * 0];
            const auto c_j = p_prim_info[j / 3 + p_prim_count * 1];
            const auto x_j = p_prim_info[j / 3 + p_prim_count * 2];
            const auto y_j = p_prim_info[j / 3 + p_prim_count * 3];
            const auto z_j = p_prim_info[j / 3 + p_prim_count * 4];

            const auto a_k = s_prim_info[k + s_prim_count * 0];
            const auto c_k = s_prim_info[k + s_prim_count * 1];
            const auto x_k = s_prim_info[k + s_prim_count * 2];
            const auto y_k = s_prim_info[k + s_prim_count * 3];
            const auto z_k = s_prim_info[k + s_prim_count * 4];

            const auto a_l = p_prim_info[l / 3 + p_prim_count * 0];
            const auto c_l = p_prim_info[l / 3 + p_prim_count * 1];
            const auto x_l = p_prim_info[l / 3 + p_prim_count * 2];
            const auto y_l = p_prim_info[l / 3 + p_prim_count * 3];
            const auto z_l = p_prim_info[l / 3 + p_prim_count * 4];

            const auto i_cart = i % 3;
            const auto j_cart = j % 3;
            const auto l_cart = l % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F3_t[4];

            gpu::computeBoysFunction(F3_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 3, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);
            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};
            const double rkl[3] = {y_l - y_k, z_l - z_k, x_l - x_k};

            const auto S_ij_10 = (a_j / (a_i + a_j)) * rij[i_cart] * S_ij_00;
            const auto S_ij_01 = -(a_i / (a_i + a_j)) * rij[j_cart] * S_ij_00;

            const auto S_ij_11 = (

                    (i_cart == j_cart ? 1.0 : 0.0) * (0.5 / (a_i + a_j)) +

                    (a_i * a_j / ((a_i + a_j) * (a_i + a_j))) * (-rij[i_cart]) * rij[j_cart]

                    ) * S_ij_00;

            const auto S_kl_01 = -(a_k / (a_k + a_l)) * rkl[l_cart] * S_kl_00;

            const double eri_ijkl = Lambda * (

                    S_kl_01 * S_ij_11 * F3_t[0] +

                    S_kl_00 * S_ij_11 * (-(a_i + a_j) / (a_k + a_l + a_i + a_j)) * rPQ[l_cart] * F3_t[1] +

                    S_kl_01 * S_ij_10 * ((a_k + a_l) / (a_k + a_l + a_i + a_j)) * rPQ[j_cart] * F3_t[1] +

                    S_kl_00 * S_ij_10 / (a_k + a_l + a_i + a_j) * (

                        (a_k + a_l) * (a_i + a_j) / (a_k + a_l + a_i + a_j) * (-rPQ[j_cart]) * rPQ[l_cart] * F3_t[2] +

                        (j_cart == l_cart ? 1.0 : 0.0) * 0.5 * F3_t[1]

                    ) +

                    S_kl_01 * S_ij_01 * ((a_k + a_l) / (a_k + a_l + a_i + a_j)) * rPQ[i_cart] * F3_t[1] +

                    S_kl_00 * S_ij_01 / (a_k + a_l + a_i + a_j) * (

                        (a_k + a_l) * (a_i + a_j) / (a_k + a_l + a_i + a_j) * (-rPQ[i_cart]) * rPQ[l_cart] * F3_t[2] +

                        (i_cart == l_cart ? 1.0 : 0.0) * 0.5 * F3_t[1]

                    ) +

                    S_kl_01 * S_ij_00 * (a_k + a_l) / (a_k + a_l + a_i + a_j) * (

                        (a_k + a_l) / (a_k + a_l + a_i + a_j) * rPQ[i_cart] * rPQ[j_cart] * F3_t[2] -

                        (i_cart == j_cart ? 1.0 : 0.0) * 0.5 / (a_i + a_j) * F3_t[1]

                    ) +

                    S_kl_00 * S_ij_00 * (-(a_k + a_l)) / ((a_k + a_l + a_i + a_j) * (a_k + a_l + a_i + a_j)) * (

                        (a_k + a_l) * (a_i + a_j) / (a_k + a_l + a_i + a_j) * rPQ[i_cart] * rPQ[j_cart] * rPQ[l_cart] * F3_t[3] +

                        ((l_cart == i_cart ? 1.0 : 0.0) * (-rPQ[j_cart]) + 
                         (l_cart == j_cart ? 1.0 : 0.0) * (-rPQ[i_cart]) +
                         (i_cart == j_cart ? 1.0 : 0.0) * (-rPQ[l_cart])) * 0.5 * F3_t[2]

                    ));

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * sp_mat_D[kl] * 2.0;
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < pp_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
computeCoulombFockPPPP(double*         mat_J,
                       const double*   p_prim_info,
                       const uint32_t  p_prim_count,
                       const double    max_D,
                       const double*   pp_mat_D,
                       const double*   pp_mat_Q,
                       const uint32_t* pp_first_inds,
                       const uint32_t* pp_second_inds,
                       const uint32_t  pp_prim_pair_count,
                       const double*   boys_func_table,
                       const double*   boys_func_ft)
{
    // each thread block scans over [ij|??] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ij = blockDim.x * blockIdx.x + threadIdx.x;

    double J_ij = 0.0;

    skip_thread_block = 0;

    for (uint32_t m = 0; m < (pp_prim_pair_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t kl = m * TILE_DIM + threadIdx.y;

        // TODO: add D_kl into ket side

        if ((kl < pp_prim_pair_count) && (ij < pp_prim_pair_count) && (std::fabs(pp_mat_Q[ij] * pp_mat_Q[kl] * max_D) > 1.0e-12))
        {
            const auto i = pp_first_inds[ij];
            const auto j = pp_second_inds[ij];

            const auto k = pp_first_inds[kl];
            const auto l = pp_second_inds[kl];

            const auto a_i = p_prim_info[i / 3 + p_prim_count * 0];
            const auto c_i = p_prim_info[i / 3 + p_prim_count * 1];
            const auto x_i = p_prim_info[i / 3 + p_prim_count * 2];
            const auto y_i = p_prim_info[i / 3 + p_prim_count * 3];
            const auto z_i = p_prim_info[i / 3 + p_prim_count * 4];

            const auto a_j = p_prim_info[j / 3 + p_prim_count * 0];
            const auto c_j = p_prim_info[j / 3 + p_prim_count * 1];
            const auto x_j = p_prim_info[j / 3 + p_prim_count * 2];
            const auto y_j = p_prim_info[j / 3 + p_prim_count * 3];
            const auto z_j = p_prim_info[j / 3 + p_prim_count * 4];

            const auto a_k = p_prim_info[k / 3 + p_prim_count * 0];
            const auto c_k = p_prim_info[k / 3 + p_prim_count * 1];
            const auto x_k = p_prim_info[k / 3 + p_prim_count * 2];
            const auto y_k = p_prim_info[k / 3 + p_prim_count * 3];
            const auto z_k = p_prim_info[k / 3 + p_prim_count * 4];

            const auto a_l = p_prim_info[l / 3 + p_prim_count * 0];
            const auto c_l = p_prim_info[l / 3 + p_prim_count * 1];
            const auto x_l = p_prim_info[l / 3 + p_prim_count * 2];
            const auto y_l = p_prim_info[l / 3 + p_prim_count * 3];
            const auto z_l = p_prim_info[l / 3 + p_prim_count * 4];

            const auto i_cart = i % 3;
            const auto j_cart = j % 3;
            const auto k_cart = k % 3;
            const auto l_cart = l % 3;

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
            const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rPQ[3] = {(a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j),
                                   (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j),
                                   (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j)};

            const auto r2_PQ = rPQ[0] * rPQ[0] + rPQ[1] * rPQ[1] + rPQ[2] * rPQ[2];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

            double F4_t[5];

            gpu::computeBoysFunction(F4_t, (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ, 4, boys_func_table, boys_func_ft);

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);
            const auto S_kl_00 = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};
            const double rkl[3] = {y_l - y_k, z_l - z_k, x_l - x_k};

            const auto S_ij_10 = (a_j / (a_i + a_j)) * rij[i_cart] * S_ij_00;
            const auto S_ij_01 = -(a_i / (a_i + a_j)) * rij[j_cart] * S_ij_00;

            const auto S_ij_11 = (

                    (i_cart == j_cart ? 1.0 : 0.0) * (0.5 / (a_i + a_j)) +

                    (a_i * a_j / ((a_i + a_j) * (a_i + a_j))) * (-rij[i_cart]) * rij[j_cart]

                    ) * S_ij_00;

            const auto S_kl_10 = (a_l / (a_k + a_l)) * rkl[k_cart] * S_kl_00;
            const auto S_kl_01 = -(a_k / (a_k + a_l)) * rkl[l_cart] * S_kl_00;

            const auto S_kl_11 = (

                    (k_cart == l_cart ? 1.0 : 0.0) * (0.5 / (a_k + a_l)) +

                    (a_k * a_l / ((a_k + a_l) * (a_k + a_l))) * (-rkl[k_cart]) * rkl[l_cart]

                    ) * S_kl_00;

            const double eri_ijkl = Lambda * (

                    S_ij_11 * S_kl_11 * F4_t[0]

                    + S_ij_11 * S_kl_10 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[l_cart] * F4_t[1] +

                    + S_ij_11 * S_kl_01 * (-(a_i + a_j) / (a_i + a_j + a_k + a_l)) * rPQ[k_cart] * F4_t[1] +

                    + S_ij_11 * S_kl_00 * (a_i + a_j) / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) / (a_i + a_j + a_k + a_l) * rPQ[k_cart] * rPQ[l_cart] * F4_t[2]

                        - (k_cart == l_cart ? 1.0 : 0.0) * 0.5 / (a_k + a_l) * F4_t[1]

                    )

                    + S_ij_10 * S_kl_11 * ((a_k + a_l) / (a_i + a_j + a_k + a_l)) * rPQ[j_cart] * F4_t[1] +

                    + S_ij_10 * S_kl_10 / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[j_cart]) * rPQ[l_cart] * F4_t[2]

                        + (j_cart == l_cart ? 1.0 : 0.0) * 0.5 * F4_t[1]

                    )

                    + S_ij_10 * S_kl_01 / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[j_cart]) * rPQ[k_cart] * F4_t[2]

                        + (j_cart == k_cart ? 1.0 : 0.0) * 0.5 * F4_t[1]

                    )

                    + S_ij_10 * S_kl_00 * (-(a_i + a_j)) / ((a_i + a_j + a_k + a_l) * (a_i + a_j + a_k + a_l)) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[j_cart]) * rPQ[k_cart] * rPQ[l_cart] * F4_t[3]

                        - ((j_cart == k_cart ? 1.0 : 0.0) * (-rPQ[l_cart]) + 
                           (j_cart == l_cart ? 1.0 : 0.0) * (-rPQ[k_cart]) +
                           (k_cart == l_cart ? 1.0 : 0.0) * (-rPQ[j_cart])) * 0.5 * F4_t[2]

                    )

                    + S_ij_01 * S_kl_11 * ((a_k + a_l) / (a_i + a_j + a_k + a_l)) * rPQ[i_cart] * F4_t[1] +

                    + S_ij_01 * S_kl_10 / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[i_cart]) * rPQ[l_cart] * F4_t[2]

                        + (i_cart == l_cart ? 1.0 : 0.0) * 0.5 * F4_t[1]

                    )

                    + S_ij_01 * S_kl_01 / (a_i + a_j + a_k + a_l) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[i_cart]) * rPQ[k_cart] * F4_t[2]

                        + (i_cart == k_cart ? 1.0 : 0.0) * 0.5 * F4_t[1]

                    )

                    + S_ij_01 * S_kl_00 * (-(a_i + a_j)) / ((a_i + a_j + a_k + a_l) * (a_i + a_j + a_k + a_l)) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (-rPQ[i_cart]) * rPQ[k_cart] * rPQ[l_cart] * F4_t[3]

                        - ((i_cart == k_cart ? 1.0 : 0.0) * (-rPQ[l_cart]) + 
                           (i_cart == l_cart ? 1.0 : 0.0) * (-rPQ[k_cart]) +
                           (k_cart == l_cart ? 1.0 : 0.0) * (-rPQ[i_cart])) * 0.5 * F4_t[2]

                    )

                    + S_ij_00 * S_kl_11 * (a_k + a_l) / (a_i + a_j + a_k + a_l) * (

                        (a_k + a_l) / (a_i + a_j + a_k + a_l) * rPQ[i_cart] * rPQ[j_cart] * F4_t[2]

                        - (i_cart == j_cart ? 1.0 : 0.0) * 0.5 / (a_i + a_j) * F4_t[1]

                    )

                    + S_ij_00 * S_kl_10 * (-(a_k + a_l)) / ((a_i + a_j + a_k + a_l) * (a_i + a_j + a_k + a_l)) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * rPQ[i_cart] * rPQ[j_cart] * rPQ[l_cart] * F4_t[3]

                        + ((i_cart == j_cart ? 1.0 : 0.0) * (-rPQ[l_cart]) + 
                           (i_cart == l_cart ? 1.0 : 0.0) * (-rPQ[j_cart]) +
                           (j_cart == l_cart ? 1.0 : 0.0) * (-rPQ[i_cart])) * 0.5 * F4_t[2]

                    )

                    + S_ij_00 * S_kl_01 * (-(a_k + a_l)) / ((a_i + a_j + a_k + a_l) * (a_i + a_j + a_k + a_l)) * (

                        (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * rPQ[i_cart] * rPQ[j_cart] * rPQ[k_cart] * F4_t[3]

                        + ((i_cart == j_cart ? 1.0 : 0.0) * (-rPQ[k_cart]) + 
                           (i_cart == k_cart ? 1.0 : 0.0) * (-rPQ[j_cart]) +
                           (j_cart == k_cart ? 1.0 : 0.0) * (-rPQ[i_cart])) * 0.5 * F4_t[2]

                    )

                    + S_ij_00 * S_kl_00 / ((a_i + a_j + a_k + a_l) * (a_i + a_j + a_k + a_l)) * (

                        (a_i + a_j) * (a_i + a_j) * (a_k + a_l) * (a_k + a_l) / ((a_i + a_j + a_k + a_l) * (a_i + a_j + a_k + a_l)) * rPQ[i_cart] * rPQ[j_cart] * rPQ[k_cart] * rPQ[l_cart] * F4_t[4]

                        - (a_i + a_j) * (a_k + a_l) / ((a_i + a_j + a_k + a_l) * 2.0) * (

                              (i_cart == j_cart ? 1.0 : 0.0) * rPQ[k_cart] * rPQ[l_cart]
                            + (i_cart == k_cart ? 1.0 : 0.0) * rPQ[j_cart] * rPQ[l_cart]
                            + (i_cart == l_cart ? 1.0 : 0.0) * rPQ[j_cart] * rPQ[k_cart]
                            + (j_cart == k_cart ? 1.0 : 0.0) * rPQ[i_cart] * rPQ[l_cart]
                            + (j_cart == l_cart ? 1.0 : 0.0) * rPQ[i_cart] * rPQ[k_cart]
                            + (k_cart == l_cart ? 1.0 : 0.0) * rPQ[i_cart] * rPQ[j_cart]

                        ) * F4_t[3]

                        + ((i_cart == j_cart ? 1.0 : 0.0) * (k_cart == l_cart ? 1.0 : 0.0) + 
                           (i_cart == k_cart ? 1.0 : 0.0) * (j_cart == l_cart ? 1.0 : 0.0) +
                           (i_cart == l_cart ? 1.0 : 0.0) * (j_cart == k_cart ? 1.0 : 0.0)) * 0.25 * F4_t[2]

                    ));

            // NOTE: doubling for off-diagonal elements of D due to k<=>l symmetry
            ERIs[threadIdx.y][threadIdx.x] = eri_ijkl * pp_mat_D[kl] * (k == l ? 1.0 : 2.0);
        }
        else
        {
            ERIs[threadIdx.y][threadIdx.x] = 0.0;

            // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
            if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
        }

        __syncthreads();

        // early exit for thread block
        if (skip_thread_block == 1) break;

        if (threadIdx.y == 0)
        {
            for (uint32_t n = 0; n < TILE_DIM; n++)
            {
                J_ij += ERIs[n][threadIdx.x];
            }
        }

        __syncthreads();
    }

    if ((threadIdx.y == 0) && (ij < pp_prim_pair_count))
    {
        mat_J[ij] = J_ij;
    }
}

__global__ void
cudaFockK(double*         mat_K,
          const uint32_t* pari_inds_i,
          const uint32_t* pari_inds_k,
          const double*   s_prim_info,
          const uint32_t* s_prim_aoinds,
          const uint32_t  s_prim_count,
          const double    max_D,
          const double*   mat_D_full,
          const double*   mat_Q_for_K,
          const uint32_t* first_inds_for_K,
          const uint32_t* second_inds_for_K,
          const uint32_t  ss_prim_pair_count,
          const uint32_t  naos)
{
    // each thread block scans over [i?|k?] and sum up to a primitive J matrix element

    __shared__ double ERIs[TILE_DIM][TILE_DIM + 1];
    __shared__ uint32_t skip_thread_block;

    const uint32_t ik = blockIdx.x;

    double K_ik = 0.0;

    for (uint32_t m = 0; m < (s_prim_count + TILE_DIM - 1) / TILE_DIM; m++)
    {
        const uint32_t j = m * TILE_DIM + threadIdx.y;

        skip_thread_block = 0;

        for (uint32_t n = 0; n < (s_prim_count + TILE_DIM - 1) / TILE_DIM; n++)
        {
            const uint32_t l = n * TILE_DIM + threadIdx.x;

            if ((ik < ss_prim_pair_count) && (j < s_prim_count) && (l < s_prim_count))
            {
                const auto i = pari_inds_i[ik];
                const auto k = pari_inds_k[ik];

                const auto Q_ij = mat_Q_for_K[i * s_prim_count + j];
                const auto Q_kl = mat_Q_for_K[k * s_prim_count + l];

                if (std::fabs(Q_ij * Q_kl * max_D) > 1.0e-12)
                {
                    auto j_prim = second_inds_for_K[i * s_prim_count + j];
                    auto l_prim = second_inds_for_K[k * s_prim_count + l];

                    auto j_cgto = s_prim_aoinds[j_prim];
                    auto l_cgto = s_prim_aoinds[l_prim];

                    const auto a_i = s_prim_info[i + s_prim_count * 0];
                    const auto c_i = s_prim_info[i + s_prim_count * 1];
                    const auto x_i = s_prim_info[i + s_prim_count * 2];
                    const auto y_i = s_prim_info[i + s_prim_count * 3];
                    const auto z_i = s_prim_info[i + s_prim_count * 4];

                    const auto a_j = s_prim_info[j_prim + s_prim_count * 0];
                    const auto c_j = s_prim_info[j_prim + s_prim_count * 1];
                    const auto x_j = s_prim_info[j_prim + s_prim_count * 2];
                    const auto y_j = s_prim_info[j_prim + s_prim_count * 3];
                    const auto z_j = s_prim_info[j_prim + s_prim_count * 4];

                    const auto a_k = s_prim_info[k + s_prim_count * 0];
                    const auto c_k = s_prim_info[k + s_prim_count * 1];
                    const auto x_k = s_prim_info[k + s_prim_count * 2];
                    const auto y_k = s_prim_info[k + s_prim_count * 3];
                    const auto z_k = s_prim_info[k + s_prim_count * 4];

                    const auto a_l = s_prim_info[l_prim + s_prim_count * 0];
                    const auto c_l = s_prim_info[l_prim + s_prim_count * 1];
                    const auto x_l = s_prim_info[l_prim + s_prim_count * 2];
                    const auto y_l = s_prim_info[l_prim + s_prim_count * 3];
                    const auto z_l = s_prim_info[l_prim + s_prim_count * 4];

                    const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);
                    const auto r2_kl = (x_l - x_k) * (x_l - x_k) + (y_l - y_k) * (y_l - y_k) + (z_l - z_k) * (z_l - z_k);

                    const auto x_PQ = (a_k * x_k + a_l * x_l) / (a_k + a_l) - (a_i * x_i + a_j * x_j) / (a_i + a_j);
                    const auto y_PQ = (a_k * y_k + a_l * y_l) / (a_k + a_l) - (a_i * y_i + a_j * y_j) / (a_i + a_j);
                    const auto z_PQ = (a_k * z_k + a_l * z_l) / (a_k + a_l) - (a_i * z_i + a_j * z_j) / (a_i + a_j);

                    const auto r2_PQ = x_PQ * x_PQ + y_PQ * y_PQ + z_PQ * z_PQ;

                    // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

                    const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_k + a_l) / (MATH_CONST_PI * (a_i + a_j + a_k + a_l)));

                    const auto t = (a_i + a_j) * (a_k + a_l) / (a_i + a_j + a_k + a_l) * r2_PQ;

                    // TODO: higher order Boys function

                    const double F0_t = (t == 0.0 ? 1.0 : std::sqrt(MATH_CONST_PI / (4.0 * t)) * std::erf(std::sqrt(t)));

                    const auto S_ij = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);
                    const auto S_kl = c_k * c_l * std::pow(MATH_CONST_PI / (a_k + a_l), 1.5) * std::exp(-a_k * a_l / (a_k + a_l) * r2_kl);

                    ERIs[threadIdx.y][threadIdx.x] = Lambda * S_ij * S_kl * F0_t * mat_D_full[j_cgto * naos + l_cgto];
                }
                else
                {
                    ERIs[threadIdx.y][threadIdx.x] = 0.0;

                    // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
                    if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
                }
            }
            else
            {
                ERIs[threadIdx.y][threadIdx.x] = 0.0;

                // indicator for early exit for thread block (ERIs[0][0] has the largest upper bound)
                if ((threadIdx.y == 0) && (threadIdx.x == 0)) skip_thread_block = 1;
            }

            __syncthreads();

            // early exit for thread block
            if (skip_thread_block == 1) break;

            if ((threadIdx.y == 0) && (threadIdx.x == 0))
            {
                for (uint32_t y = 0; y < TILE_DIM; y++)
                {
                    for (uint32_t x = 0; x < TILE_DIM; x++)
                    {
                        K_ik += ERIs[y][x];
                    }
                }
            }

            __syncthreads();
        }
    }

    if ((threadIdx.y == 0) && (threadIdx.x == 0) && (ik < ss_prim_pair_count))
    {
        mat_K[ik] = K_ik;
    }
}

auto
computeEriSSSS(const CMolecule& molecule, const CMolecularBasis& basis, const CAODensityMatrix& densityMatrix) -> CDenseMatrix
{
    auto rank = mpi::rank(MPI_COMM_WORLD);

    if (rank % 8 == 0) hipSafe(hipSetDevice(4));
    if (rank % 8 == 1) hipSafe(hipSetDevice(5));
    if (rank % 8 == 2) hipSafe(hipSetDevice(2));
    if (rank % 8 == 3) hipSafe(hipSetDevice(3));
    if (rank % 8 == 4) hipSafe(hipSetDevice(6));
    if (rank % 8 == 5) hipSafe(hipSetDevice(7));
    if (rank % 8 == 6) hipSafe(hipSetDevice(0));
    if (rank % 8 == 7) hipSafe(hipSetDevice(1));

    CMultiTimer timer;

    timer.start("Total timing");

    timer.start("Preparation");

    // GTOs blocks and number of AOs

    const auto gto_blocks = gtofunc::makeGtoBlocks(basis, molecule);

    const auto naos = gtofunc::getNumberOfAtomicOrbitals(gto_blocks);

    std::string errnaos("gpu::computeEriSSSS: Inconsistent number of AOs");

    errors::assertMsgCritical((naos == densityMatrix.getNumberOfRows(0)) && (naos == densityMatrix.getNumberOfColumns(0)), errnaos);

    // Boys function (tabulated for order 0-28)

    std::vector<double> boys_func_table((28 + 1) * 121 * 7);

    for (int64_t bf_order = 0; bf_order <= 28; bf_order++)
    {
        const auto bf_table = boysfunc::getBoysFuncTable(bf_order);

        auto bf_data = boys_func_table.data() + bf_order * 121 * 7;

        for (int64_t r = 0; r < 121; r++)
        {
            for (int64_t c = 0; c < 7; c++)
            {
                bf_data[r * 7 + c] = bf_table[r][c];
            }
        }
    }

    double* d_boys_func_table;

    hipSafe(hipMalloc(&d_boys_func_table, boys_func_table.size() * sizeof(double)));

    hipSafe(hipMemcpy(d_boys_func_table, boys_func_table.data(), boys_func_table.size() * sizeof(double), hipMemcpyHostToDevice));

    std::vector<double> boys_func_ft{1.0,        1.0 / 3.0,  1.0 / 5.0,  1.0 / 7.0,  1.0 / 9.0,  1.0 / 11.0, 1.0 / 13.0,
                                     1.0 / 15.0, 1.0 / 17.0, 1.0 / 19.0, 1.0 / 21.0, 1.0 / 23.0, 1.0 / 25.0, 1.0 / 27.0,
                                     1.0 / 29.0, 1.0 / 31.0, 1.0 / 33.0, 1.0 / 35.0, 1.0 / 37.0, 1.0 / 39.0, 1.0 / 41.0,
                                     1.0 / 43.0, 1.0 / 45.0, 1.0 / 47.0, 1.0 / 49.0, 1.0 / 51.0, 1.0 / 53.0, 1.0 / 55.0};

    double* d_boys_func_ft;

    hipSafe(hipMalloc(&d_boys_func_ft, boys_func_ft.size() * sizeof(double)));

    hipSafe(hipMemcpy(d_boys_func_ft, boys_func_ft.data(), boys_func_ft.size() * sizeof(double), hipMemcpyHostToDevice));

    // gto blocks

    int64_t s_prim_count = 0;
    int64_t p_prim_count = 0;

    for (const auto& gto_block : gto_blocks)
    {
        const auto ncgtos = gto_block.getNumberOfBasisFunctions();
        const auto npgtos = gto_block.getNumberOfPrimitives();

        const auto gto_ang = gto_block.getAngularMomentum();

        if (gto_ang == 0) s_prim_count += npgtos * ncgtos;
        if (gto_ang == 1) p_prim_count += npgtos * ncgtos;
    }

    // S gto block

    std::vector<double>   s_prim_info(5 * s_prim_count);
    std::vector<uint32_t> s_prim_aoinds(1 * s_prim_count);

    gtoinfo::updatePrimitiveInfoForS(s_prim_info.data(), s_prim_aoinds.data(), s_prim_count, gto_blocks);

    double*   d_s_prim_info;
    uint32_t* d_s_prim_aoinds;

    hipSafe(hipMalloc(&d_s_prim_info, s_prim_info.size() * sizeof(double)));
    hipSafe(hipMalloc(&d_s_prim_aoinds, s_prim_aoinds.size() * sizeof(uint32_t)));

    hipSafe(hipMemcpy(d_s_prim_info, s_prim_info.data(), s_prim_info.size() * sizeof(double), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_s_prim_aoinds, s_prim_aoinds.data(), s_prim_aoinds.size() * sizeof(uint32_t), hipMemcpyHostToDevice));

    // P gto block

    std::vector<double>   p_prim_info(5 * p_prim_count);
    std::vector<uint32_t> p_prim_aoinds(3 * p_prim_count);

    gtoinfo::updatePrimitiveInfoForP(p_prim_info.data(), p_prim_aoinds.data(), p_prim_count, gto_blocks);

    double*   d_p_prim_info;
    uint32_t* d_p_prim_aoinds;

    hipSafe(hipMalloc(&d_p_prim_info, p_prim_info.size() * sizeof(double)));
    hipSafe(hipMalloc(&d_p_prim_aoinds, p_prim_aoinds.size() * sizeof(uint32_t)));

    hipSafe(hipMemcpy(d_p_prim_info, p_prim_info.data(), p_prim_info.size() * sizeof(double), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_p_prim_aoinds, p_prim_aoinds.data(), p_prim_aoinds.size() * sizeof(uint32_t), hipMemcpyHostToDevice));

    // S-S gto block pair and S-P gto block pair

    auto ss_prim_pair_count = s_prim_count * (s_prim_count + 1) / 2;
    auto sp_prim_pair_count = s_prim_count * p_prim_count * 3;
    auto pp_prim_pair_count = p_prim_count * 3 * (p_prim_count * 3 + 1) / 2;

    CDenseMatrix ss_mat_Q_orig(s_prim_count, s_prim_count);
    CDenseMatrix sp_mat_Q_orig(s_prim_count, p_prim_count * 3);
    CDenseMatrix pp_mat_Q_orig(p_prim_count * 3, p_prim_count * 3);

    std::vector<std::tuple<double, int64_t, int64_t, double>> ss_mat_Q_D_sorted;
    std::vector<std::tuple<double, int64_t, int64_t, double>> sp_mat_Q_D_sorted;
    std::vector<std::tuple<double, int64_t, int64_t, double>> pp_mat_Q_D_sorted;

    auto dens_ptr = densityMatrix.alphaDensity(0);

    for (int64_t i = 0, ij = 0; i < s_prim_count; i++)
    {
        const auto a_i = s_prim_info[i + s_prim_count * 0];
        const auto c_i = s_prim_info[i + s_prim_count * 1];
        const auto x_i = s_prim_info[i + s_prim_count * 2];
        const auto y_i = s_prim_info[i + s_prim_count * 3];
        const auto z_i = s_prim_info[i + s_prim_count * 4];

        const auto i_cgto = s_prim_aoinds[i];

        // S-S gto block pair

        for (int64_t j = i; j < s_prim_count; j++, ij++)
        {
            const auto a_j = s_prim_info[j + s_prim_count * 0];
            const auto c_j = s_prim_info[j + s_prim_count * 1];
            const auto x_j = s_prim_info[j + s_prim_count * 2];
            const auto y_j = s_prim_info[j + s_prim_count * 3];
            const auto z_j = s_prim_info[j + s_prim_count * 4];

            const auto j_cgto = s_prim_aoinds[j];

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);

            const auto a_ij = a_i + a_j;

            const auto S_ij = c_i * c_j * std::pow(MATH_CONST_PI / a_ij, 1.5) * std::exp(-a_i * a_j / a_ij * r2_ij);

            const auto F0_t = boysfunc::getBoysFunction(0.0, 0, boys_func_table.data(), boys_func_ft.data());

            const auto eri_ijij = F0_t[0] * S_ij * S_ij * std::sqrt(4.0 * a_ij * a_ij / (a_ij + a_ij) / MATH_CONST_PI);

            const auto sqrt_ijij = std::sqrt(eri_ijij);

            const auto D_ij = dens_ptr[i_cgto * naos + j_cgto];

            ss_mat_Q_orig.row(i)[j] = sqrt_ijij;

            if (i != j) ss_mat_Q_orig.row(j)[i] = sqrt_ijij;

            ss_mat_Q_D_sorted.push_back(std::make_tuple(sqrt_ijij, i, j, D_ij));
        }

        // S-P gto block pair

        for (int64_t j = 0; j < p_prim_count; j++, ij++)
        {
            const auto a_j = p_prim_info[j + p_prim_count * 0];
            const auto c_j = p_prim_info[j + p_prim_count * 1];
            const auto x_j = p_prim_info[j + p_prim_count * 2];
            const auto y_j = p_prim_info[j + p_prim_count * 3];
            const auto z_j = p_prim_info[j + p_prim_count * 4];

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);

            const auto a_ij = a_i + a_j;

            const auto S_ij_0 = c_i * c_j * std::pow(MATH_CONST_PI / a_ij, 1.5) * std::exp(-a_i * a_j / a_ij * r2_ij);

            const auto Lambda = std::sqrt(4.0 * a_ij * a_ij / (a_ij + a_ij) / MATH_CONST_PI);

            for (int64_t s = 0; s < 3; s++)
            {
                const auto j_cgto = p_prim_aoinds[j + p_prim_count * s];

                // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

                // p-1: py
                // p_0: pz
                // p+1: px

                double S_ij_1;

                if (s == 0) S_ij_1 = -(a_i / a_ij) * (y_j - y_i) * S_ij_0;
                if (s == 1) S_ij_1 = -(a_i / a_ij) * (z_j - z_i) * S_ij_0;
                if (s == 2) S_ij_1 = -(a_i / a_ij) * (x_j - x_i) * S_ij_0;

                const auto F1_t = boysfunc::getBoysFunction(0.0, 1, boys_func_table.data(), boys_func_ft.data());

                const double eri_ijij = Lambda * (S_ij_1 * S_ij_1 * F1_t[0] + S_ij_0 * S_ij_0 * F1_t[1] / (2.0 * (a_ij + a_ij)));

                const auto sqrt_ijij = std::sqrt(eri_ijij);

                const auto D_ij = dens_ptr[i_cgto * naos + j_cgto];

                // TODO: think about the ordering of cartesian components

                sp_mat_Q_orig.row(i)[j * 3 + s] = sqrt_ijij;

                sp_mat_Q_D_sorted.push_back(std::make_tuple(sqrt_ijij, i, j * 3 + s, D_ij));
            }
        }
    }

    // P-P gto block pair

    for (int64_t i = 0; i < p_prim_count; i++)
    {
        const auto a_i = p_prim_info[i + p_prim_count * 0];
        const auto c_i = p_prim_info[i + p_prim_count * 1];
        const auto x_i = p_prim_info[i + p_prim_count * 2];
        const auto y_i = p_prim_info[i + p_prim_count * 3];
        const auto z_i = p_prim_info[i + p_prim_count * 4];

        for (int64_t j = i; j < p_prim_count; j++)
        {
            const auto a_j = p_prim_info[j + p_prim_count * 0];
            const auto c_j = p_prim_info[j + p_prim_count * 1];
            const auto x_j = p_prim_info[j + p_prim_count * 2];
            const auto y_j = p_prim_info[j + p_prim_count * 3];
            const auto z_j = p_prim_info[j + p_prim_count * 4];

            const auto r2_ij = (x_j - x_i) * (x_j - x_i) + (y_j - y_i) * (y_j - y_i) + (z_j - z_i) * (z_j - z_i);

            // Electron. J. Theor. Chem., Vol. 2, 66–70 (1997)

            const auto Lambda = std::sqrt(4.0 * (a_i + a_j) * (a_i + a_j) / (MATH_CONST_PI * (a_i + a_j + a_i + a_j)));

            const auto F2_t = boysfunc::getBoysFunction(0.0, 2, boys_func_table.data(), boys_func_ft.data());

            const auto S_ij_00 = c_i * c_j * std::pow(MATH_CONST_PI / (a_i + a_j), 1.5) * std::exp(-a_i * a_j / (a_i + a_j) * r2_ij);

            // p-1: py
            // p_0: pz
            // p+1: px

            const double rij[3] = {y_j - y_i, z_j - z_i, x_j - x_i};

            const double rPQ[3] = {0.0, 0.0, 0.0};

            for (int64_t i_cart = 0; i_cart < 3; i_cart++)
            {
                const auto i_cgto = p_prim_aoinds[i + p_prim_count * i_cart];

                auto j_cart_start = (j == i ? i_cart : 0);

                for (int64_t j_cart = j_cart_start; j_cart < 3; j_cart++)
                {
                    const auto j_cgto = p_prim_aoinds[j + p_prim_count * j_cart];

                    const auto S_ij_10 = (a_j / (a_i + a_j)) * rij[i_cart] * S_ij_00;
                    const auto S_ij_01 = -(a_i / (a_i + a_j)) * rij[j_cart] * S_ij_00;

                    const auto S_ij_11 = (

                            (i_cart == j_cart ? 1.0 : 0.0) * (0.5 / (a_i + a_j)) +

                            (a_i * a_j / ((a_i + a_j) * (a_i + a_j))) * (-rij[i_cart]) * rij[j_cart]

                            ) * S_ij_00;

                    const double eri_ijij = Lambda * (

                            S_ij_11 * S_ij_11 * F2_t[0]

                            + S_ij_11 * S_ij_00 * (a_i + a_j) / (a_i + a_j + a_i + a_j) * ( -(i_cart == j_cart ? 1.0 : 0.0) * 0.5 / (a_i + a_j) * F2_t[1] )

                            + S_ij_10 * S_ij_10 / (a_i + a_j + a_i + a_j) * ( 0.5 * F2_t[1] )

                            + S_ij_10 * S_ij_01 / (a_i + a_j + a_i + a_j) * ( (j_cart == i_cart ? 1.0 : 0.0) * 0.5 * F2_t[1] )

                            + S_ij_01 * S_ij_10 / (a_i + a_j + a_i + a_j) * ( (i_cart == j_cart ? 1.0 : 0.0) * 0.5 * F2_t[1] )

                            + S_ij_01 * S_ij_01 / (a_i + a_j + a_i + a_j) * ( 0.5 * F2_t[1] )

                            + S_ij_00 * S_ij_11 * (a_i + a_j) / (a_i + a_j + a_i + a_j) * ( -(i_cart == j_cart ? 1.0 : 0.0) * 0.5 / (a_i + a_j) * F2_t[1] )

                            + S_ij_00 * S_ij_00 / ((a_i + a_j + a_i + a_j) * (a_i + a_j + a_i + a_j)) * (

                                  ((i_cart == j_cart ? 1.0 : 0.0) * (i_cart == j_cart ? 1.0 : 0.0) + 1.0 +
                                   (i_cart == j_cart ? 1.0 : 0.0) * (j_cart == i_cart ? 1.0 : 0.0)) * 0.25 * F2_t[2]

                            ));

                    const auto sqrt_ijij = std::sqrt(eri_ijij);

                    // TODO: think about the ordering of cartesian components

                    pp_mat_Q_orig.row(i * 3 + i_cart)[j * 3 + j_cart] = sqrt_ijij;

                    if (i * 3 + i_cart != j * 3 + j_cart) pp_mat_Q_orig.row(j * 3 + j_cart)[i * 3 + i_cart] = sqrt_ijij;

                    const auto D_ij = dens_ptr[i_cgto * naos + j_cgto];

                    pp_mat_Q_D_sorted.push_back(std::make_tuple(sqrt_ijij, i * 3 + i_cart, j * 3 + j_cart, D_ij));
                }
            }
        }
    }

    std::sort(ss_mat_Q_D_sorted.begin(), ss_mat_Q_D_sorted.end());
    std::reverse(ss_mat_Q_D_sorted.begin(), ss_mat_Q_D_sorted.end());

    std::sort(sp_mat_Q_D_sorted.begin(), sp_mat_Q_D_sorted.end());
    std::reverse(sp_mat_Q_D_sorted.begin(), sp_mat_Q_D_sorted.end());

    std::sort(pp_mat_Q_D_sorted.begin(), pp_mat_Q_D_sorted.end());
    std::reverse(pp_mat_Q_D_sorted.begin(), pp_mat_Q_D_sorted.end());

    // K preparation

    std::vector<double>   mat_Q_for_K(s_prim_count * s_prim_count);
    std::vector<uint32_t> first_inds_for_K(s_prim_count * s_prim_count);
    std::vector<uint32_t> second_inds_for_K(s_prim_count * s_prim_count);

    // TODO: use uplo_index

    for (int64_t i = 0; i < s_prim_count; i++)
    {
        std::vector<std::tuple<double, int64_t, int64_t>> Q_vec_sorted;

        const auto Q_i = ss_mat_Q_orig.row(i);

        for (int64_t j = 0; j < s_prim_count; j++)
        {
            Q_vec_sorted.push_back(std::make_tuple(Q_i[j], i, j));
        }

        std::sort(Q_vec_sorted.begin(), Q_vec_sorted.end());
        std::reverse(Q_vec_sorted.begin(), Q_vec_sorted.end());

        for (int64_t j = 0; j < s_prim_count; j++)
        {
            const auto& q_ij = Q_vec_sorted[j];

            auto q_val = std::get<0>(q_ij);
            auto i_idx = std::get<1>(q_ij);
            auto j_idx = std::get<2>(q_ij);

            mat_Q_for_K[i * s_prim_count + j]       = q_val;
            first_inds_for_K[i * s_prim_count + j]  = static_cast<uint32_t>(i_idx);
            second_inds_for_K[i * s_prim_count + j] = static_cast<uint32_t>(j_idx);
        }
    }

    std::vector<uint32_t> pair_inds_i(ss_prim_pair_count);
    std::vector<uint32_t> pair_inds_k(ss_prim_pair_count);

    for (int64_t i = 0, ik = 0; i < s_prim_count; i++)
    {
        for (int64_t k = i; k < s_prim_count; k++, ik++)
        {
            pair_inds_i[ik] = i;
            pair_inds_k[ik] = k;
        }
    }

    // sorted Q, D, and indices on host

    std::vector<double> ss_mat_Q(ss_prim_pair_count);
    std::vector<double> ss_mat_D(ss_prim_pair_count);
    std::vector<double> ss_mat_J(ss_prim_pair_count);

    std::vector<uint32_t> ss_first_inds(ss_prim_pair_count);
    std::vector<uint32_t> ss_second_inds(ss_prim_pair_count);

    double ss_max_D = 0.0;

    for (int64_t ij = 0; ij < ss_prim_pair_count; ij++)
    {
        const auto& q_ij = ss_mat_Q_D_sorted[ij];

        auto sqrt_ijij = std::get<0>(q_ij);
        auto i         = std::get<1>(q_ij);
        auto j         = std::get<2>(q_ij);
        auto D_ij      = std::get<3>(q_ij);

        ss_mat_Q[ij] = sqrt_ijij;
        ss_mat_D[ij] = D_ij;

        ss_first_inds[ij]  = static_cast<uint32_t>(i);
        ss_second_inds[ij] = static_cast<uint32_t>(j);

        if (std::fabs(D_ij) > ss_max_D) ss_max_D = std::fabs(D_ij);
    }

    std::vector<double> sp_mat_Q(sp_prim_pair_count);
    std::vector<double> sp_mat_D(sp_prim_pair_count);
    std::vector<double> sp_mat_J(sp_prim_pair_count);

    std::vector<uint32_t> sp_first_inds(sp_prim_pair_count);
    std::vector<uint32_t> sp_second_inds(sp_prim_pair_count);

    double sp_max_D = 0.0;

    for (int64_t ij = 0; ij < sp_prim_pair_count; ij++)
    {
        const auto& q_ij = sp_mat_Q_D_sorted[ij];

        auto sqrt_ijij = std::get<0>(q_ij);
        auto i         = std::get<1>(q_ij);
        auto j         = std::get<2>(q_ij);
        auto D_ij      = std::get<3>(q_ij);

        sp_mat_Q[ij] = sqrt_ijij;
        sp_mat_D[ij] = D_ij;

        sp_first_inds[ij]  = static_cast<uint32_t>(i);
        sp_second_inds[ij] = static_cast<uint32_t>(j);

        if (std::fabs(D_ij) > sp_max_D) sp_max_D = std::fabs(D_ij);
    }

    std::vector<double> pp_mat_Q(pp_prim_pair_count);
    std::vector<double> pp_mat_D(pp_prim_pair_count);
    std::vector<double> pp_mat_J(pp_prim_pair_count);

    std::vector<uint32_t> pp_first_inds(pp_prim_pair_count);
    std::vector<uint32_t> pp_second_inds(pp_prim_pair_count);

    double pp_max_D = 0.0;

    for (int64_t ij = 0; ij < pp_prim_pair_count; ij++)
    {
        const auto& q_ij = pp_mat_Q_D_sorted[ij];

        auto sqrt_ijij = std::get<0>(q_ij);
        auto i         = std::get<1>(q_ij);
        auto j         = std::get<2>(q_ij);
        auto D_ij      = std::get<3>(q_ij);

        pp_mat_Q[ij] = sqrt_ijij;
        pp_mat_D[ij] = D_ij;

        pp_first_inds[ij]  = static_cast<uint32_t>(i);
        pp_second_inds[ij] = static_cast<uint32_t>(j);

        if (std::fabs(D_ij) > pp_max_D) pp_max_D = std::fabs(D_ij);
    }

    // sorted Q, D, and indices on device

    double *  d_mat_J, *d_mat_D, *d_ss_mat_Q, *d_sp_mat_Q, *d_pp_mat_Q;
    uint32_t *d_ss_first_inds, *d_ss_second_inds;
    uint32_t *d_sp_first_inds, *d_sp_second_inds;
    uint32_t *d_pp_first_inds, *d_pp_second_inds;

    auto max_prim_pair_count = std::max(ss_prim_pair_count, std::max(sp_prim_pair_count, pp_prim_pair_count));

    hipSafe(hipMalloc(&d_mat_D, max_prim_pair_count * sizeof(double)));
    hipSafe(hipMalloc(&d_mat_J, max_prim_pair_count * sizeof(double)));

    hipSafe(hipMalloc(&d_ss_mat_Q, ss_prim_pair_count * sizeof(double)));
    hipSafe(hipMalloc(&d_sp_mat_Q, sp_prim_pair_count * sizeof(double)));
    hipSafe(hipMalloc(&d_pp_mat_Q, pp_prim_pair_count * sizeof(double)));

    hipSafe(hipMalloc(&d_ss_first_inds, ss_prim_pair_count * sizeof(uint32_t)));
    hipSafe(hipMalloc(&d_ss_second_inds, ss_prim_pair_count * sizeof(uint32_t)));

    hipSafe(hipMalloc(&d_sp_first_inds, sp_prim_pair_count * sizeof(uint32_t)));
    hipSafe(hipMalloc(&d_sp_second_inds, sp_prim_pair_count * sizeof(uint32_t)));

    hipSafe(hipMalloc(&d_pp_first_inds, pp_prim_pair_count * sizeof(uint32_t)));
    hipSafe(hipMalloc(&d_pp_second_inds, pp_prim_pair_count * sizeof(uint32_t)));

    hipSafe(hipMemcpy(d_ss_mat_Q, ss_mat_Q.data(), ss_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_sp_mat_Q, sp_mat_Q.data(), sp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_pp_mat_Q, pp_mat_Q.data(), pp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

    hipSafe(hipMemcpy(d_ss_first_inds, ss_first_inds.data(), ss_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_ss_second_inds, ss_second_inds.data(), ss_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));

    hipSafe(hipMemcpy(d_sp_first_inds, sp_first_inds.data(), sp_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_sp_second_inds, sp_second_inds.data(), sp_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));

    hipSafe(hipMemcpy(d_pp_first_inds, pp_first_inds.data(), pp_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_pp_second_inds, pp_second_inds.data(), pp_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));

    double*   d_mat_K;
    uint32_t *d_pair_inds_i, *d_pair_inds_k;

    hipSafe(hipMalloc(&d_mat_K, ss_prim_pair_count * sizeof(double)));

    hipSafe(hipMalloc(&d_pair_inds_i, ss_prim_pair_count * sizeof(uint32_t)));
    hipSafe(hipMalloc(&d_pair_inds_k, ss_prim_pair_count * sizeof(uint32_t)));

    hipSafe(hipMemcpy(d_pair_inds_i, pair_inds_i.data(), ss_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_pair_inds_k, pair_inds_k.data(), ss_prim_pair_count * sizeof(uint32_t), hipMemcpyHostToDevice));

    double *  d_mat_Q_for_K, *d_mat_D_full;
    uint32_t *d_first_inds_for_K, *d_second_inds_for_K;

    hipSafe(hipMalloc(&d_mat_D_full, naos * naos * sizeof(double)));
    hipSafe(hipMalloc(&d_mat_Q_for_K, s_prim_count * s_prim_count * sizeof(double)));

    hipSafe(hipMalloc(&d_first_inds_for_K, s_prim_count * s_prim_count * sizeof(uint32_t)));
    hipSafe(hipMalloc(&d_second_inds_for_K, s_prim_count * s_prim_count * sizeof(uint32_t)));

    hipSafe(hipMemcpy(d_mat_D_full, dens_ptr, naos * naos * sizeof(double), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_mat_Q_for_K, mat_Q_for_K.data(), s_prim_count * s_prim_count * sizeof(double), hipMemcpyHostToDevice));

    hipSafe(hipMemcpy(d_first_inds_for_K, first_inds_for_K.data(), s_prim_count * s_prim_count * sizeof(uint32_t), hipMemcpyHostToDevice));
    hipSafe(hipMemcpy(d_second_inds_for_K, second_inds_for_K.data(), s_prim_count * s_prim_count * sizeof(uint32_t), hipMemcpyHostToDevice));

    timer.stop("Preparation");

    CDenseMatrix mat_Fock(naos, naos);

    mat_Fock.zero();

    timer.start("J computation");

    // compute J

    // J: (SS|SS)

    hipSafe(hipMemcpy(d_mat_D, ss_mat_D.data(), ss_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

    dim3 threads_per_block(TILE_DIM, TILE_DIM);

    dim3 num_blocks((ss_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

    hipLaunchKernelGGL(cudaFockJ, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                 d_s_prim_info,
                                                 static_cast<uint32_t>(s_prim_count),
                                                 ss_max_D,
                                                 d_mat_D,
                                                 d_ss_mat_Q,
                                                 d_ss_first_inds,
                                                 d_ss_second_inds,
                                                 static_cast<uint32_t>(ss_prim_pair_count),
                                                 d_boys_func_table,
                                                 d_boys_func_ft);

    hipSafe(hipMemcpy(ss_mat_J.data(), d_mat_J, ss_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

    for (int64_t ij = 0; ij < ss_prim_pair_count; ij++)
    {
        const auto i = ss_first_inds[ij];
        const auto j = ss_second_inds[ij];

        const auto i_cgto = s_prim_aoinds[i];
        const auto j_cgto = s_prim_aoinds[j];

        mat_Fock.row(i_cgto)[j_cgto] += ss_mat_J[ij] * 2.0;

        if (i != j) mat_Fock.row(j_cgto)[i_cgto] += ss_mat_J[ij] * 2.0;
    }

    if (sp_prim_pair_count > 0)
    {
        // J: (SS|SP)

        hipSafe(hipMemcpy(d_mat_D, sp_mat_D.data(), sp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

        threads_per_block = dim3(TILE_DIM, TILE_DIM);

        num_blocks = dim3((ss_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

        hipLaunchKernelGGL(computeCoulombFockSSSP, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                     d_s_prim_info,
                                                     static_cast<uint32_t>(s_prim_count),
                                                     d_p_prim_info,
                                                     static_cast<uint32_t>(p_prim_count),
                                                     sp_max_D,
                                                     d_mat_D,
                                                     d_ss_mat_Q,
                                                     d_sp_mat_Q,
                                                     d_ss_first_inds,
                                                     d_ss_second_inds,
                                                     static_cast<uint32_t>(ss_prim_pair_count),
                                                     d_sp_first_inds,
                                                     d_sp_second_inds,
                                                     static_cast<uint32_t>(sp_prim_pair_count),
                                                     d_boys_func_table,
                                                     d_boys_func_ft);

        hipSafe(hipMemcpy(ss_mat_J.data(), d_mat_J, ss_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

        for (int64_t ij = 0; ij < ss_prim_pair_count; ij++)
        {
            const auto i = ss_first_inds[ij];
            const auto j = ss_second_inds[ij];

            const auto i_cgto = s_prim_aoinds[i];
            const auto j_cgto = s_prim_aoinds[j];

            mat_Fock.row(i_cgto)[j_cgto] += ss_mat_J[ij] * 2.0;

            if (i != j) mat_Fock.row(j_cgto)[i_cgto] += ss_mat_J[ij] * 2.0;
        }

        // J: (SP|SS)

        hipSafe(hipMemcpy(d_mat_D, ss_mat_D.data(), ss_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

        threads_per_block = dim3(TILE_DIM, TILE_DIM);

        num_blocks = dim3((sp_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

        hipLaunchKernelGGL(computeCoulombFockSPSS, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                     d_s_prim_info,
                                                     static_cast<uint32_t>(s_prim_count),
                                                     d_p_prim_info,
                                                     static_cast<uint32_t>(p_prim_count),
                                                     ss_max_D,
                                                     d_mat_D,
                                                     d_ss_mat_Q,
                                                     d_sp_mat_Q,
                                                     d_ss_first_inds,
                                                     d_ss_second_inds,
                                                     static_cast<uint32_t>(ss_prim_pair_count),
                                                     d_sp_first_inds,
                                                     d_sp_second_inds,
                                                     static_cast<uint32_t>(sp_prim_pair_count),
                                                     d_boys_func_table,
                                                     d_boys_func_ft);

        hipSafe(hipMemcpy(sp_mat_J.data(), d_mat_J, sp_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

        for (int64_t ij = 0; ij < sp_prim_pair_count; ij++)
        {
            const auto i = sp_first_inds[ij];
            const auto j = sp_second_inds[ij];

            const auto i_cgto = s_prim_aoinds[i];

            // TODO: think about the ordering of cartesian components
            const auto j_cgto = p_prim_aoinds[(j / 3) + p_prim_count * (j % 3)];

            mat_Fock.row(i_cgto)[j_cgto] += sp_mat_J[ij] * 2.0;
            mat_Fock.row(j_cgto)[i_cgto] += sp_mat_J[ij] * 2.0;
        }

        // J: (SP|SP)

        hipSafe(hipMemcpy(d_mat_D, sp_mat_D.data(), sp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

        threads_per_block = dim3(TILE_DIM, TILE_DIM);

        num_blocks = dim3((sp_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

        hipLaunchKernelGGL(computeCoulombFockSPSP, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                     d_s_prim_info,
                                                     static_cast<uint32_t>(s_prim_count),
                                                     d_p_prim_info,
                                                     static_cast<uint32_t>(p_prim_count),
                                                     sp_max_D,
                                                     d_mat_D,
                                                     d_sp_mat_Q,
                                                     d_sp_first_inds,
                                                     d_sp_second_inds,
                                                     static_cast<uint32_t>(sp_prim_pair_count),
                                                     d_boys_func_table,
                                                     d_boys_func_ft);

        hipSafe(hipMemcpy(sp_mat_J.data(), d_mat_J, sp_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

        for (int64_t ij = 0; ij < sp_prim_pair_count; ij++)
        {
            const auto i = sp_first_inds[ij];
            const auto j = sp_second_inds[ij];

            const auto i_cgto = s_prim_aoinds[i];

            // TODO: think about the ordering of cartesian components
            const auto j_cgto = p_prim_aoinds[(j / 3) + p_prim_count * (j % 3)];

            mat_Fock.row(i_cgto)[j_cgto] += sp_mat_J[ij] * 2.0;
            mat_Fock.row(j_cgto)[i_cgto] += sp_mat_J[ij] * 2.0;
        }

        // J: (SP|PP)

        if (pp_prim_pair_count > 0)
        {
            hipSafe(hipMemcpy(d_mat_D, pp_mat_D.data(), pp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

            threads_per_block = dim3(TILE_DIM, TILE_DIM);

            num_blocks = dim3((sp_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

            hipLaunchKernelGGL(computeCoulombFockSPPP, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                         d_s_prim_info,
                                                         static_cast<uint32_t>(s_prim_count),
                                                         d_p_prim_info,
                                                         static_cast<uint32_t>(p_prim_count),
                                                         pp_max_D,
                                                         d_mat_D,
                                                         d_sp_mat_Q,
                                                         d_pp_mat_Q,
                                                         d_sp_first_inds,
                                                         d_sp_second_inds,
                                                         static_cast<uint32_t>(sp_prim_pair_count),
                                                         d_pp_first_inds,
                                                         d_pp_second_inds,
                                                         static_cast<uint32_t>(pp_prim_pair_count),
                                                         d_boys_func_table,
                                                         d_boys_func_ft);

            hipSafe(hipMemcpy(sp_mat_J.data(), d_mat_J, sp_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

            for (int64_t ij = 0; ij < sp_prim_pair_count; ij++)
            {
                const auto i = sp_first_inds[ij];
                const auto j = sp_second_inds[ij];

                const auto i_cgto = s_prim_aoinds[i];

                // TODO: think about the ordering of cartesian components
                const auto j_cgto = p_prim_aoinds[(j / 3) + p_prim_count * (j % 3)];

                mat_Fock.row(i_cgto)[j_cgto] += sp_mat_J[ij] * 2.0;
                mat_Fock.row(j_cgto)[i_cgto] += sp_mat_J[ij] * 2.0;
            }
        }
    }

    if (pp_prim_pair_count > 0)
    {
        // J: (SS|PP)

        hipSafe(hipMemcpy(d_mat_D, pp_mat_D.data(), pp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

        threads_per_block = dim3(TILE_DIM, TILE_DIM);

        num_blocks = dim3((ss_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

        hipLaunchKernelGGL(computeCoulombFockSSPP, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                     d_s_prim_info,
                                                     static_cast<uint32_t>(s_prim_count),
                                                     d_p_prim_info,
                                                     static_cast<uint32_t>(p_prim_count),
                                                     pp_max_D,
                                                     d_mat_D,
                                                     d_ss_mat_Q,
                                                     d_pp_mat_Q,
                                                     d_ss_first_inds,
                                                     d_ss_second_inds,
                                                     static_cast<uint32_t>(ss_prim_pair_count),
                                                     d_pp_first_inds,
                                                     d_pp_second_inds,
                                                     static_cast<uint32_t>(pp_prim_pair_count),
                                                     d_boys_func_table,
                                                     d_boys_func_ft);

        hipSafe(hipMemcpy(ss_mat_J.data(), d_mat_J, ss_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

        for (int64_t ij = 0; ij < ss_prim_pair_count; ij++)
        {
            const auto i = ss_first_inds[ij];
            const auto j = ss_second_inds[ij];

            const auto i_cgto = s_prim_aoinds[i];
            const auto j_cgto = s_prim_aoinds[j];

            mat_Fock.row(i_cgto)[j_cgto] += ss_mat_J[ij] * 2.0;

            if (i != j) mat_Fock.row(j_cgto)[i_cgto] += ss_mat_J[ij] * 2.0;
        }

        // J: (PP|SS)

        hipSafe(hipMemcpy(d_mat_D, ss_mat_D.data(), ss_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

        threads_per_block = dim3(TILE_DIM, TILE_DIM);

        num_blocks = dim3((pp_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

        hipLaunchKernelGGL(computeCoulombFockPPSS, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                     d_s_prim_info,
                                                     static_cast<uint32_t>(s_prim_count),
                                                     d_p_prim_info,
                                                     static_cast<uint32_t>(p_prim_count),
                                                     ss_max_D,
                                                     d_mat_D,
                                                     d_ss_mat_Q,
                                                     d_pp_mat_Q,
                                                     d_ss_first_inds,
                                                     d_ss_second_inds,
                                                     static_cast<uint32_t>(ss_prim_pair_count),
                                                     d_pp_first_inds,
                                                     d_pp_second_inds,
                                                     static_cast<uint32_t>(pp_prim_pair_count),
                                                     d_boys_func_table,
                                                     d_boys_func_ft);

        hipSafe(hipMemcpy(pp_mat_J.data(), d_mat_J, pp_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

        for (int64_t ij = 0; ij < pp_prim_pair_count; ij++)
        {
            const auto i = pp_first_inds[ij];
            const auto j = pp_second_inds[ij];

            // TODO: think about the ordering of cartesian components
            const auto i_cgto = p_prim_aoinds[(i / 3) + p_prim_count * (i % 3)];
            const auto j_cgto = p_prim_aoinds[(j / 3) + p_prim_count * (j % 3)];

            mat_Fock.row(i_cgto)[j_cgto] += pp_mat_J[ij] * 2.0;

            if (i != j) mat_Fock.row(j_cgto)[i_cgto] += pp_mat_J[ij] * 2.0;
        }

        if (sp_prim_pair_count > 0)
        {
            // J: (PP|SP)

            hipSafe(hipMemcpy(d_mat_D, sp_mat_D.data(), sp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

            threads_per_block = dim3(TILE_DIM, TILE_DIM);

            num_blocks = dim3((pp_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

            hipLaunchKernelGGL(computeCoulombFockPPSP, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                         d_s_prim_info,
                                                         static_cast<uint32_t>(s_prim_count),
                                                         d_p_prim_info,
                                                         static_cast<uint32_t>(p_prim_count),
                                                         sp_max_D,
                                                         d_mat_D,
                                                         d_sp_mat_Q,
                                                         d_pp_mat_Q,
                                                         d_sp_first_inds,
                                                         d_sp_second_inds,
                                                         static_cast<uint32_t>(sp_prim_pair_count),
                                                         d_pp_first_inds,
                                                         d_pp_second_inds,
                                                         static_cast<uint32_t>(pp_prim_pair_count),
                                                         d_boys_func_table,
                                                         d_boys_func_ft);

            hipSafe(hipMemcpy(pp_mat_J.data(), d_mat_J, pp_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

            for (int64_t ij = 0; ij < pp_prim_pair_count; ij++)
            {
                const auto i = pp_first_inds[ij];
                const auto j = pp_second_inds[ij];

                // TODO: think about the ordering of cartesian components
                const auto i_cgto = p_prim_aoinds[(i / 3) + p_prim_count * (i % 3)];
                const auto j_cgto = p_prim_aoinds[(j / 3) + p_prim_count * (j % 3)];

                mat_Fock.row(i_cgto)[j_cgto] += pp_mat_J[ij] * 2.0;

                if (i != j) mat_Fock.row(j_cgto)[i_cgto] += pp_mat_J[ij] * 2.0;
            }
        }

        // J: (PP|PP)

        hipSafe(hipMemcpy(d_mat_D, pp_mat_D.data(), pp_prim_pair_count * sizeof(double), hipMemcpyHostToDevice));

        threads_per_block = dim3(TILE_DIM, TILE_DIM);

        num_blocks = dim3((pp_prim_pair_count + threads_per_block.x - 1) / threads_per_block.x, 1);

        hipLaunchKernelGGL(computeCoulombFockPPPP, num_blocks, threads_per_block, 0, 0, d_mat_J,
                                                     d_p_prim_info,
                                                     static_cast<uint32_t>(p_prim_count),
                                                     pp_max_D,
                                                     d_mat_D,
                                                     d_pp_mat_Q,
                                                     d_pp_first_inds,
                                                     d_pp_second_inds,
                                                     static_cast<uint32_t>(pp_prim_pair_count),
                                                     d_boys_func_table,
                                                     d_boys_func_ft);

        hipSafe(hipMemcpy(pp_mat_J.data(), d_mat_J, pp_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

        for (int64_t ij = 0; ij < pp_prim_pair_count; ij++)
        {
            const auto i = pp_first_inds[ij];
            const auto j = pp_second_inds[ij];

            // TODO: think about the ordering of cartesian components
            const auto i_cgto = p_prim_aoinds[(i / 3) + p_prim_count * (i % 3)];
            const auto j_cgto = p_prim_aoinds[(j / 3) + p_prim_count * (j % 3)];

            mat_Fock.row(i_cgto)[j_cgto] += pp_mat_J[ij] * 2.0;

            if (i != j) mat_Fock.row(j_cgto)[i_cgto] += pp_mat_J[ij] * 2.0;
        }
    
    }

    timer.stop("J computation");

    timer.start("K computation");

    threads_per_block = dim3(TILE_DIM, TILE_DIM);

    num_blocks = dim3(ss_prim_pair_count, 1);

    hipLaunchKernelGGL(cudaFockK, num_blocks, threads_per_block, 0, 0, d_mat_K,
                                                 d_pair_inds_i,
                                                 d_pair_inds_k,
                                                 d_s_prim_info,
                                                 d_s_prim_aoinds,
                                                 static_cast<uint32_t>(s_prim_count),
                                                 ss_max_D,
                                                 d_mat_D_full,
                                                 d_mat_Q_for_K,
                                                 d_first_inds_for_K,
                                                 d_second_inds_for_K,
                                                 static_cast<uint32_t>(ss_prim_pair_count),
                                                 static_cast<uint32_t>(naos));

    std::vector<double> mat_K(ss_prim_pair_count);

    hipSafe(hipMemcpy(mat_K.data(), d_mat_K, ss_prim_pair_count * sizeof(double), hipMemcpyDeviceToHost));

    timer.stop("K computation");

    timer.start("J/K to Fock");

    // put K back to Fock

    /*
    for (int64_t ik = 0; ik < ss_prim_pair_count; ik++)
    {
        const auto i = pair_inds_i[ik];
        const auto k = pair_inds_k[ik];

        const auto i_cgto = s_prim_aoinds[i];
        const auto k_cgto = s_prim_aoinds[k];

        mat_Fock.row(i_cgto)[k_cgto] += mat_K[ik] * (-1.0);

        if (i != k) mat_Fock.row(k_cgto)[i_cgto] += mat_K[ik] * (-1.0);
    }
    */

    timer.stop("J/K to Fock");

    hipSafe(hipFree(d_boys_func_table));
    hipSafe(hipFree(d_boys_func_ft));

    hipSafe(hipFree(d_s_prim_info));
    hipSafe(hipFree(d_s_prim_aoinds));

    hipSafe(hipFree(d_p_prim_info));
    hipSafe(hipFree(d_p_prim_aoinds));

    hipSafe(hipFree(d_mat_D));
    hipSafe(hipFree(d_mat_J));

    hipSafe(hipFree(d_ss_mat_Q));
    hipSafe(hipFree(d_sp_mat_Q));

    hipSafe(hipFree(d_ss_first_inds));
    hipSafe(hipFree(d_ss_second_inds));

    hipSafe(hipFree(d_sp_first_inds));
    hipSafe(hipFree(d_sp_second_inds));

    hipSafe(hipFree(d_mat_K));

    hipSafe(hipFree(d_pair_inds_i));
    hipSafe(hipFree(d_pair_inds_k));

    hipSafe(hipFree(d_mat_D_full));
    hipSafe(hipFree(d_mat_Q_for_K));

    hipSafe(hipFree(d_first_inds_for_K));
    hipSafe(hipFree(d_second_inds_for_K));

    timer.stop("Total timing");

    std::cout << "\nTiming of ERIs on GPU\n";
    std::cout << "-----------------------\n";
    std::cout << timer.getSummary() << std::endl;

    return mat_Fock;
}

}  // namespace gpu
