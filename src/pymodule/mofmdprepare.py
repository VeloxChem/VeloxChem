import numpy as np
import re
import shutil
import pandas as pd
import linecache
from .mofutils import create_lG
import networkx as nx
from pathlib import Path

from .molecule import Molecule
from .molecularbasis import MolecularBasis
from .scfunrestdriver import ScfUnrestrictedDriver
from .mmforcefieldgenerator import MMForceFieldGenerator


def tempgro(output, all_array):
    atoms_number = len(all_array)

    newgro = []
    with open(output, "w") as fp:
        newgro.append("generated by MOF_BUILD" + "\n" + str(atoms_number) +
                      "\n")
        for i in range(atoms_number):
            line = all_array[i]

            value_atom_number = int(i + 1)  # atom_number
            value_label = re.sub('\d', '', line[0]) + re.sub(
                '\D', '', line[2])  # atom_label
            value_resname = str(line[4])[0:3]  # residue_name
            value_resnumber = int(line[5])  # residue number
            value_x = 0.1 * float(line[6])  # x
            value_y = 0.1 * float(line[7])  # y
            value_z = 0.1 * float(line[8])  # z
            formatted_line = "%5d%-5s%5s%5d%8.3f%8.3f%8.3f" % (
                value_resnumber,
                value_resname,
                value_label,
                value_atom_number,
                value_x,
                value_y,
                value_z,
            )
            newgro.append(formatted_line + "\n")
        tail = "100 100 100 \n"
        newgro.append(tail)
        fp.writelines(newgro)


def temp_xyz(output, placed_all):
    atoms_number = len(placed_all)
    newxyz = []
    with open(output, "w") as fp:
        newxyz.append(
            str(atoms_number) + "\n" + "generated by MOF_BUILD" + "\n")
        for i in range(atoms_number):

            value_label = placed_all[i][0]  # atom_label
            value_label = re.sub(r"\d", "", value_label)
            value_x = float(placed_all[i][-3])  # x
            value_y = float(placed_all[i][-2])  # y
            value_z = float(placed_all[i][-1])  # z
            formatted_line = "%-5s%8.3f%8.3f%8.3f" % (
                value_label,
                value_x,
                value_y,
                value_z,
            )
            newxyz.append(formatted_line + "\n")
        fp.writelines(newxyz)


def temp_xyz_nm(output, placed_all):
    atoms_number = len(placed_all)
    newxyz = []
    with open(output, "w") as fp:
        newxyz.append(
            str(atoms_number) + "\n" + "generated by MOF_BUILD" + "\n")
        for i in range(atoms_number):
            value_label = placed_all[i][2]  # atom_label
            value_label = re.sub(r"\d", "", value_label)
            value_x = float(placed_all[i][-3]) * 10  # x
            value_y = float(placed_all[i][-2]) * 10  # y
            value_z = float(placed_all[i][-1]) * 10  # z
            formatted_line = "%-5s%8.3f%8.3f%8.3f" % (
                value_label,
                value_x,
                value_y,
                value_z,
            )
            newxyz.append(formatted_line + "\n")
        fp.writelines(newxyz)


##################below are from forcefield ####################
def ff_gen_xyz(
    f,
    charge=0,
    residue_name="MOL",
    show=True,
    scf_basis="sto-3g",
    scf_conv=1e-3,
    scf_xcfun="b3lyp",
    scf_maxiter=30,
):
    m1 = Molecule.read_xyz_file(f)
    gromacs_file = Path(f).stem
    res_name = residue_name
    if show:
        m1.show(atom_indices=True)
    m1.set_charge(charge)
    basis = MolecularBasis.read(m1, scf_basis)
    scf_drv = ScfUnrestrictedDriver()  # TODO:
    # scf_drv.guess_unpaired_electrons = '1(1)' #TODO:
    scf_drv.conv_thresh = scf_conv
    scf_drv.max_iter = scf_maxiter
    scf_drv.xcfun = scf_xcfun
    scf_results = scf_drv.compute(m1, basis)
    scf_drv.ostream.mute()
    ff_gen = MMForceFieldGenerator()
    ff_gen.ostream.mute()
    ff_gen.create_topology(m1, basis, scf_results)
    ff_gen.write_gromacs_files(str(Path("Residues", gromacs_file)), res_name)
    return str(Path("Residues", f"{gromacs_file}.itp"))


# 1.ff_gen to generate ff for user_linker
# 2. parse ff
# 3. mapping and replace new mof_edge ff

###ff_name = ff_gen_xyz(linker_file,charge=-3)
##ff_name='/Users/chenxili/GitHub/MOFbuilder/tests/Residues/triph.itp'
##mapping = get_mapping_between_nometal_linker_xyz(linker_topic,center_frag_nodes_num,center_Xs,single_frag_nodes_num,frag_Xs,linker_file, new_xyz='Residues/EDGE.xyz')
##map_name = 'linker_ff_mapping'
##parsed_path=parseff(ff_name)
##map_path = write_mapping_file(parsed_path,mapping,map_name)
##map_forcefield_by_xyz(parsed_path,map_path,linker_file, new_xyz='EDGE.xyz')


def get_residues_forcefield(
    arr,
    node_split_dict,
    DUMMY_NODE,
    linker_file,
    linker_file_ff,
    linker_topic,
    center_frag_nodes_num,
    center_Xs,
    single_frag_nodes_num,
    frag_Xs,
):
    new_arr_list = []
    print("fetching residues...")
    restypes = [name for name in np.unique(arr[:, 1])]

    Path("Residues").mkdir(parents=True, exist_ok=True)

    res_info = {}

    res_previous_sum = 0
    for res in restypes:
        type_arr = arr[arr[:, 1] == res]
        sample_idx = type_arr[-1, 0]
        sample_arr = type_arr[type_arr[:, 0] == sample_idx]
        res_numbers = len(sample_arr)

        if res in ["METAL", "HHO", "HO", "O"]:
            res_numbers = fetch_res_in_node_num(res, node_split_dict,
                                                DUMMY_NODE)
            # print(res_numbers,res)
            for i in range(len(type_arr)):
                type_arr[i, 0] = i // res_numbers + 1 + res_previous_sum
                type_arr[i, 2] = re.sub("[0-9]", "", type_arr[i, 2]) + str(
                    int(i % res_numbers + 1))
                # print(type_arr[i,0:2],re.sub('[0-9]','',type_arr[i,2])+str(int(i%res_numbers+1)))
            sample_arr = type_arr[type_arr[:, 0] == 1 + res_previous_sum]
            res_sum = int(len(type_arr) / res_numbers)
            res_info[res] = res_sum
            res_previous_sum += res_sum
            # print(res_previous_sum,res_sum,res)
            xyz_file = Path("Residues", f"{res}.xyz")
            temp_xyz_nm(xyz_file, sample_arr)
            if res == "O":
                # xtb_residue(xyz_file,-2)
                # ff_gen_xyz(xyz_file,charge=-2)
                print(res, "  fetched/optimized")
            elif res == "HO":
                # xtb_residue(xyz_file,-1)
                # ff_gen_xyz(xyz_file,charge=-1)
                print(res, "  fetched/optimized")
            elif res == "HHO":
                # xtb_residue(xyz_file,0)
                # ff_gen_xyz(xyz_file,charge=0)
                print(res, "  fetched/optimized")

            elif res == "METAL":
                print(res, "  fetched")

            ##reindex resnumber
            new_arr_list.append(type_arr)
            # print('type_arr[i,5]',type_arr[0,3:6])

        else:
            for i in range(len(type_arr)):
                type_arr[i, 0] = i // res_numbers + 1 + res_previous_sum

            res_sum = int(len(type_arr) / res_numbers)
            res_info[res] = res_sum
            res_previous_sum += res_sum
            # print(res_previous_sum,res_sum,res)
            xyz_file = Path("Residues", f"{res}.xyz")
            temp_xyz(xyz_file, sample_arr)
            if res in ["EDG", "EDGE"]:
                # xtb_residue(xyz_file,-3)
                # ff_name = ff_gen_xyz(linker_file,charge=-1*linker_topic)
                # if not os.path.exists(linker_file_ff):
                #    print("linker_file_ff not found, generating...")
                #    ff_name = ff_gen_xyz(linker_file, charge=-1 * linker_topic)
                ff_name = linker_file_ff
                mapping, metals, mol_metals = get_mapping_between_nometal_linker_xyz(
                    linker_topic,
                    center_frag_nodes_num,
                    center_Xs,
                    single_frag_nodes_num,
                    frag_Xs,
                    linker_file,
                    new_xyz="Residues/EDG.xyz",
                )
                map_name = "linker_ff_mapping"
                parsed_path = parseff(ff_name)
                map_path = write_mapping_file(parsed_path, mapping, metals,
                                              mol_metals, map_name)
                map_forcefield_by_xyz(parsed_path,
                                      map_path,
                                      linker_file,
                                      new_xyz="EDG.xyz")
                shutil.rmtree(parsed_path)
                print(res, "  mapped")
            elif res in ["HEDGE"]:
                # xtb_residue(xyz_file,-1*linker_topic+1)
                print(res, "   mapped/optimized")
            elif res in ["HHEDGE"]:
                # xtb_residue(xyz_file,-1*linker_topic+2)
                print(res, "   mapped/optimized")
            elif res in ["TERM"]:
                # xtb_residue(xyz_file,-1)
                # ff_gen_xyz(xyz_file,charge=-1,residue_name=res[:3])
                print(res, "  fetched/optimized")

            ##reindex resnumber
            new_arr_list.append(type_arr)

            # print('type_arr[i,5]',type_arr[0,3:6])
    # fetch_res_mask,_ = fetch_by_idx_resname(arr,1,sub_class)
    new_arr = np.vstack(new_arr_list)
    return new_arr, res_info, restypes


#########below are from map_forcefield.py###########


def parseff(INPUT):
    newpath = Path("Residues", "parsedfile").mkdir(parents=True, exist_ok=True)
    inputfile = str(INPUT)
    #outputfile = 'new'+inputfile.strip(".ff")
    #print(inputfile,outputfile+'.ff')
    #newpath = os.path.abspath ( '')+'/'+str(outputfile)+'/'    # input file
    #os.makedirs(newpath,exist_ok=True)
    fp = open(inputfile, 'r')
    number = []
    lineNumber = 1
    keyword = "]"  #input('Keyword:')
    for eachline in fp:  #search for keywords and get linenumber
        m = re.search(keyword, eachline)
        if m is not None:
            number.append(lineNumber - 1)  #split by linenumber
        lineNumber += 1
    number.append(len(open(INPUT).readlines()))
    number = list(set(number))
    number.sort()
    size = int(len(number))
    #print(number)
    for i in range(size - 1):
        #set output range
        start = number[i]
        end = number[i + 1]
        middlelines = linecache.getlines(inputfile)[start:end]
        section = re.findall(r'\[(.*?)\]', middlelines[0])
        title = section[0].split()[0]
        if title == 'dihedrals':
            if 'impropers' in middlelines[1]:
                title = 'dihedrals_im'
        print(title)
        fp_w = open(newpath + title + '.txt', 'w')
        for key in middlelines:
            fp_w.write(key)
        fp_w.close()
    return newpath


def readgro(input):
    with open(input, "r") as f:
        lines = f.readlines()
        number_resname = lines[0].split()[0]
        resname = re.sub(r"^\d+", "", number_resname)
        atoms = []
        for i in range(len(lines)):
            atoms.append(lines[i].split()[1])
    return resname, atoms


def readxyz(input):
    with open(input, "r") as f:
        lines = f.readlines()
        #number_resname = lines[0].split()[0]
        resname = Path(input).stem
        atoms = []
        for i in range(2, len(lines)):
            if len(lines[i].split()) == 0:
                continue
            atoms.append(lines[i].split()[0] + str(i - 1))
    return resname, atoms


def getatomtype(input):
    with open(input, "r") as f:
        lines = f.readlines()

    return lines


def getmoleculetype(input, new_resname):
    with open(input, "r") as f:
        lines = f.readlines()

    #with open("moleculetype.txt", "w") as f:
    newff = []
    newff.append(lines[0])
    newff.append(lines[1])
    values = lines[2].split()
    values[0] = new_resname
    formatted_line = "%-7s%7s" % (values[0], values[1])
    newff.append(formatted_line + "\n")
    #f.writelines(newff)
    return newff


def getatoms(input, father, son, son_atoms, son_resname):
    with open(input, "r") as f:
        lines = f.readlines()

    with open(str(Path("Residues/parsedfile/atoms1")), "w") as f:
        newff = []
        for i in range(2, len(lines)):
            values = lines[i].split()
            #print(values)
            if len(values) == 0:
                continue
            # print(son)
            res_index = father.index(values[0])
            values[0] = son[res_index]
            values[6] = float(values[6])
            values[7] = float(values[7])
            if len(values) > 8:
                values[10] = float(values[10])

                formatted_line = "%7s%7s%7s%7s%7s%7s%15.8f%15.6f%7s%7s%15.6f" % (
                    values[0],
                    values[1],
                    values[2],
                    values[3],
                    values[4],
                    values[5],
                    values[6],
                    values[7],
                    values[8],
                    values[9],
                    values[10],
                )
                newff.append(formatted_line + "\n")
            else:
                formatted_line = "%7s%7s%7s%7s%7s%7s%15.8f%15.6f" % (
                    values[0],
                    values[1],
                    values[2],
                    values[3],
                    values[4],
                    values[5],
                    values[6],
                    values[7],
                )
                newff.append(formatted_line + "\n")

        f.writelines(newff)

    df = pd.read_csv(
        str(Path("Residues/parsedfile/atoms1")),
        sep='\s+',
        names=[
            "nr",
            "type",
            "resnr",
            "residue",
            "atom",
            "cgnr",
            "charge",
            "mass",
            "typeB",
            "chargeB",
            "massB",
        ],
    )
    sondf = df.sort_values(by="nr").reset_index(drop=True)
    sondf["residue"] = son_resname
    sondf["atom"] = son_atoms
    sondf["cgnr"] = sondf.index + 1
    sondf.loc[0, "massB"] = sondf.loc[0, "charge"]
    # print(sondf)
    for i in range(1, sondf.shape[0]):
        sondf.loc[i,
                  "massB"] = sondf.loc[i - 1, "massB"] + sondf.loc[i, "charge"]

    sondf.to_csv(str(Path("Residues/parsedfile/atoms2")),
                 sep="\t",
                 header=None,
                 index=False)

    with open(str(Path("Residues/parsedfile/atoms2")), "r") as f:
        sonlines = f.readlines()

        #with open("atoms.txt", "w") as f:
        newff = []
        newff.append(lines[0])
        newff.append(lines[1])
        # print(len(sonlines))
        for i in range(len(sonlines)):
            values = sonlines[i].split()
            # print(values)
            values[6] = float(values[6])
            values[7] = float(values[7])
            if len(values) > 9:
                values[10] = float(values[10])

                formatted_line = "%7s%7s%7s%7s%7s%7s%15.8f%15.6f%7s%7s%15.6f" % (
                    values[0],
                    values[1],
                    values[2],
                    values[3],
                    values[4],
                    values[5],
                    values[6],
                    values[7],
                    values[8],
                    values[9],
                    values[10],
                )
                newff.append(formatted_line + "\n")
            else:
                formatted_line = "%7s%7s%7s%7s%7s%7s%15.8f%15.6f" % (
                    values[0],
                    values[1],
                    values[2],
                    values[3],
                    values[4],
                    values[5],
                    values[6],
                    values[7],
                )
                newff.append(formatted_line + "\n")

        #f.writelines(newff)
    Path("Residues/parsedfile/atoms1").unlink(missing_ok=True)
    Path("Residues/parsedfile/atoms2").unlink(missing_ok=True)
    return newff


def getbonds(input, father, son):
    with open(input, "r") as f:
        lines = f.readlines()

        #with open("bonds.txt", "w") as f:
        newff = []
        newff.append(lines[0])
        newff.append(lines[1])
        for i in range(2, len(lines)):
            values = lines[i].split()
            if len(values) == 0:
                continue
            ai_index = father.index(values[0])
            values[0] = son[ai_index]
            aj_index = father.index(values[1])
            values[1] = son[aj_index]
            values[3] = float(values[3])
            values[4] = float(values[4])

            formatted_line = "%7s%7s%6s%15.7f%15.6f" % (
                values[0],
                values[1],
                values[2],
                values[3],
                values[4],
            )
            newff.append(formatted_line + "\n")
        #f.writelines(newff)
        return newff


def getpairs(input, father, son):
    with open(input, "r") as f:
        lines = f.readlines()

        #with open("pairs.txt", "w") as f:
        newff = []
        newff.append(lines[0])
        newff.append(lines[1])
        for i in range(2, len(lines)):
            values = lines[i].split()
            if len(values) == 0:
                continue
            ai_index = father.index(values[0])
            values[0] = son[ai_index]
            aj_index = father.index(values[1])
            values[1] = son[aj_index]

            formatted_line = "%7s%7s%6s" % (values[0], values[1], values[2])
            newff.append(formatted_line + "\n")
        #f.writelines(newff)
        return newff


def getangles(input, father, son):
    with open(input, "r") as f:
        lines = f.readlines()

        #with open("angles.txt", "w") as f:
        newff = []
        newff.append(lines[0])
        newff.append(lines[1])
        for i in range(2, len(lines)):
            values = lines[i].split()
            if len(values) == 0:
                continue
            ai_index = father.index(values[0])
            values[0] = son[ai_index]
            aj_index = father.index(values[1])
            values[1] = son[aj_index]
            ak_index = father.index(values[2])
            values[2] = son[ak_index]

            values[4] = float(values[4])
            values[5] = float(values[5])

            formatted_line = "%7s%7s%7s%6s%13.7f%12.6f" % (
                values[0],
                values[1],
                values[2],
                values[3],
                values[4],
                values[5],
            )
            newff.append(formatted_line + "\n")
        #f.writelines(newff)
        return newff


def getdihedrals(input, father, son):
    with open(input, "r") as f:
        lines = f.readlines()

        #with open("dihedrals.txt", "w") as f:
        newff = []
        newff.append(lines[0])
        newff.append(lines[1])
        newff.append(lines[2])
        for i in range(3, len(lines)):
            values = lines[i].split()
            if len(values) == 0:
                continue
            ai_index = father.index(values[0])
            values[0] = son[ai_index]
            aj_index = father.index(values[1])
            values[1] = son[aj_index]
            ak_index = father.index(values[2])
            values[2] = son[ak_index]
            al_index = father.index(values[3])
            values[3] = son[al_index]

            values[5] = float(values[5])
            values[6] = float(values[6])

            formatted_line = "%7s%7s%7s%7s%6s%13.7f%12.7f%3s" % (
                values[0],
                values[1],
                values[2],
                values[3],
                values[4],
                values[5],
                values[6],
                values[7],
            )
            newff.append(formatted_line + "\n")
        #f.writelines(newff)
        return newff


def getdihedrals_im(input, father, son):
    with open(input, "r") as f:
        lines = f.readlines()

        #with open("dihedrals_im.txt", "w") as f:
        newff = []
        newff.append(lines[0])
        newff.append(lines[1])
        newff.append(lines[2])
        for i in range(3, len(lines)):
            values = lines[i].split()
            if len(values) == 0:
                continue
            ai_index = father.index(values[0])
            values[0] = son[ai_index]
            aj_index = father.index(values[1])
            values[1] = son[aj_index]
            ak_index = father.index(values[2])
            values[2] = son[ak_index]
            al_index = father.index(values[3])
            values[3] = son[al_index]

            values[5] = float(values[5])
            values[6] = float(values[6])

            formatted_line = "%7s%7s%7s%7s%6s%13.7f%12.7f%3s" % (
                values[0],
                values[1],
                values[2],
                values[3],
                values[4],
                values[5],
                values[6],
                values[7],
            )
            newff.append(formatted_line + "\n")
        #f.writelines(newff)
        return newff


def map_forcefield_by_xyz(path, map_path, ff_xyz, new_xyz='EDGE.xyz'):
    mapfile = map_path
    moleculetype = path + "moleculetype.txt"
    atomtype = path + "atomtypes.txt"
    atom = path + "atoms.txt"
    bond = path + "bonds.txt"
    pair = path + "pairs.txt"
    angle = path + "angles.txt"
    dihedral = path + "dihedrals.txt"
    dihedral_im = path + "dihedrals_im.txt"

    fatherxyz = ff_xyz
    sonxyz = str(Path("Residues", f"{new_xyz}"))
    new_itp = str(Path("Residues", f"{Path(new_xyz).stem}.itp"))

    with open(mapfile, "r") as f:
        father = []
        son = []
        lines = f.readlines()
        for i in range(len(lines)):
            values = lines[i].strip('\n').split()
            if len(values) == 0:
                continue
            father.append(values[0])
            son.append(values[1])

    new_resname = new_xyz.removesuffix('.xyz')[:3]
    son_resname, son_atoms = readxyz(sonxyz)
    father_resname, father_atoms = readxyz(fatherxyz)

    atomtypes = getatomtype(atomtype)
    moleculetypes = getmoleculetype(moleculetype, new_resname)
    atoms = getatoms(atom, father, son, son_atoms, new_resname)
    if Path(bond).exists():
        bonds = getbonds(bond, father, son)
    else:
        bonds = False
    if Path(pair).exists():
        pairs = getpairs(pair, father, son)
    else:
        pairs = False
    if Path(angle).exists():
        angles = getangles(angle, father, son)
    else:
        angles = False
    if Path(dihedral).exists():
        dihedrals = getdihedrals(dihedral, father, son)
    else:
        dihedrals = False
    if Path(dihedral_im).exists():
        dihedrals_im = getdihedrals_im(dihedral_im, father, son)
    else:
        dihedrals_im = False

    with open(new_itp, "w") as f:
        f.write(";generated by veloxchem, mapped by mof_builder")
        f.write("\n")
        f.write("\n")
        f.writelines(atomtypes)
        f.write("\n")
        f.writelines(moleculetypes)
        f.write("\n")
        f.writelines(atoms)
        f.write("\n")
        if bonds:
            f.writelines(bonds)
            f.write("\n")
        if pairs:
            f.writelines(pairs)
            f.write("\n")
        if angles:
            f.writelines(angles)
            f.write("\n")
        if dihedrals:
            f.writelines(dihedrals)
            f.write("\n")
        if dihedrals_im:
            f.writelines(dihedrals_im)
            f.write("\n")
    print(str(new_itp) + ' is generated')


######below are from write_mapping_between.py##########


def create_graph_from_matrix(matrix):
    """Create a graph from a given adjacency matrix."""
    G = nx.Graph()
    for i in range(len(matrix)):
        for j in range(i, len(matrix)):
            if matrix[i][j] > 0:
                G.add_edge(i, j, weight=matrix[i][j])
    return G


def find_isomorphism_and_mapping(matrix1, matrix2):
    """Check if two matrices are isomorphic and return the mapping."""
    G1 = create_graph_from_matrix(matrix1)
    G2 = create_graph_from_matrix(matrix2)

    gm = nx.algorithms.isomorphism.GraphMatcher(G1, G2)
    if gm.is_isomorphic():
        return True, gm.mapping
    else:
        print("The graphs are not isomorphic.", len(G1.nodes()),
              len(G2.nodes()))
        print("G1.edges()", G1.edges())
        print("G2.edges()", G2.edges())
        return False, None


def get_mapping_between_nometal_linker_xyz(
    linker_topic,
    center_frag_nodes_num,
    center_Xs,
    single_frag_nodes_num,
    frag_Xs,
    template_xyz,
    new_xyz="Residues/EDG.xyz",
):
    molecule = Molecule.read_xyz_file(template_xyz)
    _, mol_metals, _ = create_lG(molecule)

    m2 = Molecule.read_xyz_file(new_xyz)
    coords = m2.get_coordinates_in_angstrom()
    G, metals, mass_center_angstrom = create_lG(m2)
    if linker_topic == 2:
        matrix_mof = m2.get_connectivity_matrix()
        matrix_user = molecule.get_connectivity_matrix()
        # G_user = create_graph_from_matrix(matrix_user)
        isomorphic, mapping = find_isomorphism_and_mapping(
            matrix_mof, matrix_user)
        if isomorphic:
            print("The graphs are isomorphic.")
            print("Node mapping:", mapping)
            # permuted_matrix = permute_matrix(matrix1, mapping)
            # print("Permuted Matrix:\n", permuted_matrix)
        else:
            print("The graphs are not isomorphic.")
            #plot2dedge(G, coords, G.edges())
        return mapping, metals, mol_metals
    else:
        if len(metals) == 1:
            coords = m2.get_coordinates_in_angstrom()
            labels = m2.get_labels()
            center_nums = center_frag_nodes_num + 1
            frag_nums = single_frag_nodes_num
            # raise ValueError('cannot process molecule including metals,try the function with metal linker')

        else:
            coords = m2.get_coordinates_in_angstrom()
            labels = m2.get_labels()
            center_nums = center_frag_nodes_num
            frag_nums = single_frag_nodes_num

        center_range = range(0, center_nums)
        frag1_range = range(center_nums, center_nums + frag_nums)
        frag2_range = range(center_nums + frag_nums,
                            center_nums + frag_nums * 2)
        frag3_range = range(center_nums + frag_nums * 2,
                            center_nums + frag_nums * 3)
        frag4_range = range(center_nums + frag_nums * 3,
                            center_nums + frag_nums * 4)

        frag1_Xs = [i + center_nums for i in frag_Xs
                   ]  # frag_Xs is Xs indices in a single outer_edge_frag
        frag2_Xs = [j + frag_nums for j in frag1_Xs]
        frag3_Xs = [k + frag_nums for k in frag2_Xs]

        if linker_topic == 3:
            cn_bond = []
            frag4_Xs = []
            for x_i in center_Xs:
                x_center = coords[x_i]
                for x_j in frag1_Xs + frag2_Xs + frag3_Xs:
                    x_frag = coords[x_j]
                    if np.linalg.norm(x_center - x_frag) < 3.5:
                        cn_bond.append((x_i, x_j))
            left_xs = list(
                set(frag1_Xs + frag2_Xs + frag3_Xs) -
                set(i[1] for i in cn_bond))
            print(left_xs, "left_xs")
            if linker_topic == 3:
                for m in range(len(labels) - 3 * 3, len(labels)):
                    if labels[m] == "C":
                        x_ooc = coords[m]
                        for n in left_xs:
                            x_frag = coords[n]
                            if np.linalg.norm(x_frag - x_ooc) < 5:
                                cn_bond.append((n, m))

        elif linker_topic == 4:
            # xX bond should follow centernodeX order
            frag4_Xs = [m + frag_nums for m in frag3_Xs]
            cn_bond = []
            center_Xs.sort()
            frag_Xs = frag1_Xs + frag2_Xs + frag3_Xs + frag4_Xs
            frag_Xs.sort()

            for x_i in center_Xs:
                x_center = coords[x_i]
                for x_j in frag1_Xs + frag2_Xs + frag3_Xs + frag4_Xs:
                    x_frag = coords[x_j]
                    if np.linalg.norm(x_center - x_frag) < 4:
                        cn_bond.append((x_i, x_j))
            left_xs = list(
                set(frag1_Xs + frag2_Xs + frag3_Xs + frag4_Xs) -
                set(i[1] for i in cn_bond))
            print(left_xs, "left_xs")
            for m in range(len(labels) - 4 * 3, len(labels)):
                if labels[m] == "C":
                    x_ooc = coords[m]
                    for n in left_xs:
                        x_frag = coords[n]

                        if np.linalg.norm(x_frag - x_ooc) < 5:
                            cn_bond.append((n, m))
                            print(
                                "np.linalg.norm(x_frag-x_ooc)",
                                n,
                                m,
                                np.linalg.norm(x_frag - x_ooc),
                            )

        # seperate all frags and clean bonds between frags

        for edge in G.edges():
            if edge[0] in center_range:
                if edge[1] not in center_range:
                    G.remove_edge(edge[0], edge[1])
                    print(edge)
            elif edge[0] in frag1_range:
                if edge[1] not in frag1_range:
                    G.remove_edge(edge[0], edge[1])
                    print(edge)
            elif edge[0] in frag2_range:
                if edge[1] not in frag2_range:
                    G.remove_edge(edge[0], edge[1])
                    print(edge)
            elif edge[0] in frag3_range:
                if edge[1] not in frag3_range:
                    G.remove_edge(edge[0], edge[1])
                    print(edge)
            elif edge[0] in frag4_range:
                if edge[1] not in frag4_range:
                    G.remove_edge(edge[0], edge[1])
                    print(edge)

        if len(metals) > 0:
            # remove all edges from metal

            edges_with_Metal = list(G.edges(int(metals[0])))
            G.remove_edges_from(edges_with_Metal)

        if len(metals) == 0:
            if len(sorted(nx.connected_components(G))) == 2 * linker_topic + 1:
                print(len(sorted(nx.connected_components(G))),
                      " parts are seperated")
            else:
                print(len(sorted(nx.connected_components(G))),
                      " parts are seperated")
                # plot2dedge(G,coords,G.edges())
                raise ValueError(
                    "nx.connected_components is not linker_topic+1")
        else:
            if len(sorted(nx.connected_components(G))) == 2 * linker_topic + 2:
                print(len(sorted(nx.connected_components(G))),
                      " parts are seperated")
            else:
                print(len(sorted(nx.connected_components(G))),
                      " parts are seperated")
                # plot2dedge(G,coords,G.edges())
                raise ValueError(
                    "nx.connected_components is not linker_topic+2")

        # rebuild bond between fragXs and get_connectivity matrix of EDGE
        cn_matrix = np.zeros((G.number_of_nodes(), G.number_of_nodes()))
        # edges in seperated frags
        for edge in G.edges():
            cn_matrix[edge[0], edge[1]] = 1
            cn_matrix[edge[1], edge[0]] = 1
        # +xx #XX bonds
        for xx_cn in cn_bond:
            cn_matrix[xx_cn[0], xx_cn[1]] = 1
            cn_matrix[xx_cn[1], xx_cn[0]] = 1
            G.add_edge(int(xx_cn[0]), int(xx_cn[1]))
        if len(metals) == 0:
            if len(sorted(nx.connected_components(G))) == 1:
                print("reconnect succeed")
            else:
                print(len(sorted(nx.connected_components(G))), cn_bond)
                #plot2dedge(G, coords, G.edges())
                raise ValueError("reconnect failed")
        elif len(metals) == 1:
            if len(sorted(nx.connected_components(G))) == 2:
                print("reconnect succeed")
            else:
                print(len(sorted(nx.connected_components(G))), cn_bond)
                #plot2dedge(G, coords, G.edges())
                raise ValueError("reconnect failed")

        matrix_mof = cn_matrix
        matrix_user = molecule.get_connectivity_matrix()
        if len(mol_metals) > 0:
            matrix_user[:, mol_metals[0]] = 0
            matrix_user[mol_metals[0], :] = 0

        # G_user = create_graph_from_matrix(matrix_user)

        isomorphic, mapping = find_isomorphism_and_mapping(
            matrix_mof, matrix_user)
        if isomorphic:
            print("The graphs are isomorphic.")
            print("Node mapping:", mapping)
            # permuted_matrix = permute_matrix(matrix1, mapping)
            # print("Permuted Matrix:\n", permuted_matrix)
        else:
            print("The graphs are not isomorphic.")
            #plot2dedge(G, coords, G.edges())
    return mapping, metals, mol_metals


def write_mapping_file(path,
                       mapping,
                       metals,
                       mol_metals,
                       map_name="linker_ff_mapping"):
    map_path = str(Path(path, map_name))
    if Path(path).exists():
        with open(map_path, "w") as f:
            for i in list(mapping):
                f.write(str(mapping[i] + 1))
                f.write("\t")
                f.write(str(i + 1))
                f.write("\n")
            if len(mol_metals) > 0:
                f.write(str(mol_metals[0] + 1))
                f.write("\t")
            if len(metals) > 0:
                f.write(str(metals[0] + 1))
            f.write("\n")

        return map_path
    else:
        raise ValueError("cannot find /Residues/parsedfile/ folder")


##########below are from fetchfile.py##########


def fetch_res_in_node_num(res, node_split_dict, DUMMY_NODE):
    if res == 'METAL':
        if DUMMY_NODE:
            return node_split_dict['dummy_res_len']
        else:
            return 1
    elif res == 'HHO':
        return 3
    elif res == 'HO':
        return 2
    elif res == 'O':
        return 1
    elif res == 'OOC':
        return 3


def copy_file(old_path, new_path):
    # Check if the source file exists
    if not Path(old_path).exists():
        raise FileNotFoundError(f"The source file does not exist: {old_path}")

    # Ensure the destination directory exists
    new_dir = Path(new_path).parent
    new_dir.mkdir(parents=True, exist_ok=True)
    # Copy the file
    shutil.copy2(old_path, new_path)  # copy2 preserves metadata
    print(f"File copied from {old_path} to {new_path}")


##############below are from gro_itps.py##############


def get_gro(model_name, new_arr):
    #tempgro('2testdummy.gro',new_arr)
    #copy_file('2testdummy.gro','MD_run/TEST.gro')
    Path('MD_run').mkdir(parents=True, exist_ok=True)
    groname = 'MD_run/' + model_name + '.gro'
    tempgro(groname, new_arr)
    new_gro_path = atoms2c(groname, 3, 3, 3, 10, 10, 10)

    return new_gro_path


def get_itps(data_path, restypes, metal, node_termination, sol_list):
    # itps nodes_database, edges, sol, gas
    itp_path = Path('MD_run/itps')
    nodesitp_path = str(Path(data_path, 'nodes_itps'))
    itp_path.mkdir(parents=True, exist_ok=True)

    # copy nodes itps
    for i in Path(data_path, 'nodes_itps').rglob("*.itp"):
        itp_name = i.stem
        if itp_name in restypes or itp_name == metal:
            copy_file(i, itp_path / i.name)

    # copy EDGE(/TERM) itps
    for j in Path('Residues').rglob('*.itp'):
        itp_name = j.stem
        if itp_name in restypes:
            copy_file(j, itp_path / j.name)

    # copy TERM itp
    for k in Path(data_path, 'terminations_itps').rglob('*.itp'):
        itp_name = k.stem
        if itp_name == node_termination:
            copy_file(k, itp_path / 'TERM.itp')

    # copy solvent, ions, gas itps
    for sol in sol_list:
        copy_file(
            Path(data_path) / 'solvent_database' / f'{sol}.itp',
            itp_path / f'{sol}.itp')

    return itp_path


#########below are from atom2C.py##########


def atoms2c(output, dx, dy, dz, x, y, z):
    with open(output, 'r') as f:
        # Read the lines from the file
        lines = f.readlines()
        atoms_number = lines[1]

    newgro = []
    f_name = output.removesuffix('.gro') + '_new.gro'
    with open(f_name, 'w') as fp:
        newgro.append("generated by MOF_BUILD" + '\n' + str(atoms_number))
        # Iterate over each line in the input file
        for i in range(2, len(lines) - 1):
            # Split the line into individual values (assuming they are separated by spaces)
            #values = lines[i].split()
            value_resnumber = int((lines[i])[0:5])
            value_resname = lines[i][5:10]

            value_label = lines[i][10:15]
            value_atom_number = int(lines[i][15:20])
            value_x = float(lines[i][20:28]) + dx  #x
            value_y = float(lines[i][28:36]) + dy  #y
            value_z = float(lines[i][36:44]) + dz  #z

            formatted_line = "%5d%-5s%5s%5d%8.3f%8.3f%8.3f" % (
                value_resnumber, value_resname, value_label, value_atom_number,
                value_x, value_y, value_z)
            newgro.append(formatted_line + '\n')

        box = str(x) + '   ' + str(y) + '   ' + str(z) + '\n'

        newgro.append(box)
        fp.writelines(newgro)
        print(f_name, ' is generated')
        return f_name


########below are from top_combine.py##########


def itp_extract(itp_file):
    with open(itp_file, "r") as f:
        lines = f.readlines()
    keyword1 = "atomtypes"
    keyword2 = "moleculetype"
    for eachline in lines:  # search for keywords and get linenumber
        if re.search(keyword1, eachline):
            start = lines.index(eachline) + 2

        elif re.search(keyword2, eachline):
            end = lines.index(eachline) - 1

    target_lines = [line for line in lines[start:end] if line.strip()]

    newstart = end + 1

    with open(itp_file, "w") as fp:
        fp.writelines(lines[newstart:])

    # target_lines.append("\n")
    sec1 = target_lines
    return sec1


def extract_atomstypes(itp_path):
    all_secs = []
    for f in Path(itp_path).rglob("*itp"):
        if str(Path(f).parent) not in ["posre.itp"]:
            print(f)
            sec_atomtypes = itp_extract(f)
            all_secs += sec_atomtypes
    return all_secs


def get_unique_atomtypes(all_secs):
    types = [str(line.split()[0]) for line in all_secs]
    overlap_lines = []
    for ty in set(types):
        search = [ind for ind, value in enumerate(types) if value == ty]
        if len(search) > 1:
            overlap_lines += search[1:]
    unique_atomtypes = [
        all_secs[i] for i in range(len(all_secs)) if i not in overlap_lines
    ]
    return unique_atomtypes


def genrate_top_file(itp_path, data_path, res_info, model_name=None):
    all_secs = extract_atomstypes(itp_path)
    unique_atomtypes = get_unique_atomtypes(all_secs)
    middlelines, sectorname = parsetop(
        data_path + "/nodes_itps/template.top")  # fetch template.top

    top_res_lines = []
    for resname in list(res_info):
        line = "%-5s%16d" % (resname[:3], res_info[resname])
        top_res_lines.append(line)
        top_res_lines.append("\n")

    top_itp_lines = []
    for i in Path(itp_path).rglob("*itp"):
        if str(Path(i).parent) not in ["posre.itp"]:
            line = '#include "itps/' + Path(i).parent + '"' + "\n"
            top_itp_lines.append(line)
    sec1 = unique_atomtypes
    sec2 = top_itp_lines
    sec3 = ["MOF" + "\n" + "\n"]
    sec4 = top_res_lines + ["\n"] + ["\n"]

    newtop = (middlelines[0] + ["\n"] + ["\n"] + middlelines[1] +
              unique_atomtypes + ["\n"] + ["\n"] + top_itp_lines + ["\n"] +
              ["\n"] + middlelines[2] + ["MOF"] + ["\n"] + ["\n"] +
              middlelines[3] + ["\n"] + top_res_lines)
    if model_name is None:
        model_name = "MOF"
    topname = model_name + ".top"
    top_path = "MD_run/" + topname
    with open(top_path, "w") as f:
        f.writelines(newtop)
    print(topname, "is generated")
    return top_path


####below are from itp_process.py############################


def parsetop(inputfile):
    # newpath = os.path.abspath ( '')+'/'+str(outputfile)+'/'    # input file
    # os.makedirs(newpath,exist_ok=True)
    with open(inputfile, "r") as fp:
        original_lines = fp.readlines()

    lines = [line for line in original_lines if line.strip()]
    number = []
    includelines_number = []
    lineNumber = 1
    lineNumber_include = 1
    keyword1 = "]"  # input('Keyword:')
    for eachline in lines:  # search for keywords and get linenumber
        m = re.search(keyword1, eachline)
        if m is not None:
            number.append(lineNumber - 1)  # split by linenumber
        lineNumber += 1

    #keyword2 = "#include"  # input('Keyword:')
    #for eachline in lines:  # search for keywords and get linenumber
    #    n = re.search(keyword2, eachline)
    #    if n is not None:
    #        includelines_number.append(lineNumber_include - 1)  # split by linenumber
    #    lineNumber_include += 1
    #includelines_number.sort()
    #number.append(includelines_number[0])

    number.append(len(lines))
    number = list(set(number))
    number.sort()
    size = int(len(number))
    # print(number)

    middlelines = []
    sectorname = []
    for i in range(size - 1):
        # set output range
        start = number[i]
        end = number[i + 1]
        middlelines.append(lines[start:end])
        sectorname.append(lines[start])

        # fp_w = open(sectorname+'.txt','w')
        # for key in middlelines:
        #    fp_w.write(key)
        # fp_w.close()
    return middlelines, sectorname


# fetch atomtype sector
#for i in range(len(subfolders)):
def top_gen(itp_file, middlelines, outtopname, input_res_num):
    with open(itp_file, "r") as f:
        lines = f.readlines()

    keyword1 = "atomtype"
    keyword2 = "moleculetype"
    for eachline in lines:  # search for keywords and get linenumber
        if re.search(keyword1, eachline):
            start = lines.index(eachline) + 2
        elif re.search(keyword2, eachline):
            end = lines.index(eachline) - 1

    target_lines = [line for line in lines[start:end] if line.strip()]

    newstart = end + 1

    with open("linker.itp", "w") as fp:
        fp.writelines(lines[newstart:])

    target_lines.append("\n")
    sec1 = target_lines
    sec2 = [
        '#include "../itps/linker.itp"' + "\n" +
        '#include "../itps/tip3p.itp"' + "\n" + '#include "../itps/K.itp"' +
        "\n" + "\n"
    ]
    sec3 = ["MOF" + "\n" + "\n"]
    sec4 = ["\n" + input_res_num + "\n" + "\n"]
    newtop = (middlelines[0] + middlelines[1] + sec1 + middlelines[2] + sec2 +
              middlelines[3] + sec3 + middlelines[4] + sec4)

    #newpath = os.path.abspath ( '')+'/MDdemo/mdfiles/'   # input file
    #os.makedirs(newpath,exist_ok=True)

    with open(outtopname, "w") as f:
        f.writelines(newtop)


##################below are from mdps.py######################
def copy_mdps(data_path):
    mdp_path = Path('MD_run/mdp')
    mdp_path.mkdir(parents=True, exist_ok=True)
    for i in Path(data_path, "mdp").rglob("*.mdp"):
        copy_file(i, 'MD_run/mdp/' + str(Path(i).name))
    return mdp_path
