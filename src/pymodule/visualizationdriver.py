#
#                              VELOXCHEM
#         ----------------------------------------------------
#                     An Electronic Structure Code
#
#  Copyright Â© 2018-2024 by VeloxChem developers. All rights reserved.
#
#  SPDX-License-Identifier: LGPL-3.0-or-later
#
#  This file is part of VeloxChem.
#
#  VeloxChem is free software: you can redistribute it and/or modify it under
#  the terms of the GNU Lesser General Public License as published by the Free
#  Software Foundation, either version 3 of the License, or (at your option)
#  any later version.
#
#  VeloxChem is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
#  License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with VeloxChem. If not, see <https://www.gnu.org/licenses/>.

from mpi4py import MPI
import numpy as np
import sys
import re

from .veloxchemlib import _VisualizationDriver
from .veloxchemlib import CubicGrid
from .veloxchemlib import mpi_master
from .outputstream import OutputStream
from .errorhandler import assert_msg_critical


class VisualizationDriver:
    """
    Implements visualization driver.

    :param comm:
        The MPI communicator.
    :param ostream:
        The output stream.
    """

    def __init__(self, comm=None, ostream=None):
        """
        Initializes visualization driver.
        """

        if comm is None:
            comm = MPI.COMM_WORLD

        if ostream is None:
            if comm.Get_rank() == mpi_master():
                ostream = OutputStream(sys.stdout)
            else:
                ostream = OutputStream(None)

        self.comm = comm
        self.rank = self.comm.Get_rank()
        self.nodes = self.comm.Get_size()

        self.ostream = ostream

        self._vis_drv = _VisualizationDriver()

    @staticmethod
    def gen_cubic_grid(molecule, grid_points):
        """
        Creates cubic grid for a molecule.

        :param molecule:
            The molecule.
        :param grid_points:
            The list containing number of grid points in X, Y and Z directions.

        :return:
            The cubic grid.
        """

        n_x, n_y, n_z = grid_points[:3]

        coords = molecule.get_coordinates_in_bohr()

        x = coords[:, 0]
        y = coords[:, 1]
        z = coords[:, 2]

        atom_radii = molecule.vdw_radii_to_numpy()

        x_max = np.max(x + atom_radii * 2.0)
        x_min = np.min(x - atom_radii * 2.0)

        y_max = np.max(y + atom_radii * 2.0)
        y_min = np.min(y - atom_radii * 2.0)

        z_max = np.max(z + atom_radii * 2.0)
        z_min = np.min(z - atom_radii * 2.0)

        x_step = (x_max - x_min) / float(n_x)
        y_step = (y_max - y_min) / float(n_y)
        z_step = (z_max - z_min) / float(n_z)

        return CubicGrid([x_min, y_min, z_min], [x_step, y_step, z_step],
                         [n_x, n_y, n_z])

    @staticmethod
    def write_data(cubefile, grid, molecule, flag, index, spin):
        """
        Writes cubic grid data to cube file.

        :param cubefile:
            Name of the cube file.
        :param grid:
            The cubic grid.
        :param molecule:
            The molecule.
        :param flag:
            The flag for the type of cube data (mo, nto, density).
        :param index:
            Index (0-based) of the molecular orbital or density matrix.
        :param spin:
            Spin of the molecular orbital or density.
        """

        f_cube = open(str(cubefile), 'w')

        coords = molecule.get_coordinates_in_bohr()

        x = coords[:, 0]
        y = coords[:, 1]
        z = coords[:, 2]

        natoms = molecule.number_of_atoms()
        elem_ids = molecule.get_identifiers()

        x0, y0, z0 = grid.get_origin()
        dx, dy, dz = grid.get_step_size()
        nx, ny, nz = grid.get_num_points()

        print('Cube file generated by VeloxChem', file=f_cube)

        if flag in ['mo', 'nto']:
            print('{:s} {:d} ({:s})'.format(flag.upper(), index + 1, spin),
                  file=f_cube)
            line = '{:5d}{:12.6f}{:12.6f}{:12.6f}{:5d}'.format(
                -natoms, x0, y0, z0, 1)
            print(line, file=f_cube)

        elif flag in ['density', 'detachment', 'attachment']:
            print('Electron {:s} ({:s})'.format(flag, spin), file=f_cube)
            line = '{:5d}{:12.6f}{:12.6f}{:12.6f}{:5d}'.format(
                natoms, x0, y0, z0, 1)
            print(line, file=f_cube)

        print('{:5d}{:12.6f}{:12.6f}{:12.6f}'.format(nx, dx, 0, 0), file=f_cube)
        print('{:5d}{:12.6f}{:12.6f}{:12.6f}'.format(ny, 0, dy, 0), file=f_cube)
        print('{:5d}{:12.6f}{:12.6f}{:12.6f}'.format(nz, 0, 0, dz), file=f_cube)

        for a in range(natoms):
            line = '{:5d}{:12.6f}{:12.6f}{:12.6f}{:12.6f}'.format(
                elem_ids[a], float(elem_ids[a]), x[a], y[a], z[a])
            print(line, file=f_cube)

        if flag in ['mo', 'nto']:
            print('{:5d}{:5d}'.format(1, index + 1), file=f_cube)

        data = grid.values_to_numpy()

        for ix in range(nx):
            for iy in range(ny):
                for iz in range(nz):
                    print(' {:12.5E}'.format(data[ix, iy, iz]),
                          end='',
                          file=f_cube)
                    if iz % 6 == 5:
                        print('', file=f_cube)
                print('', file=f_cube)

        f_cube.close()

    def compute(self, cubic_grid, *args):
        """
        Computes values on cubic grid.

        :param cubic_grid:
            The cubic grid.
        """

        local_cubic_grid = self._vis_drv._create_local_cubic_grid(
            cubic_grid, self.rank, self.nodes)

        self._vis_drv._compute_local_grid(local_cubic_grid, *args)

        grid_np_arrays = self.comm.gather(local_cubic_grid.values_to_numpy(),
                                          root=mpi_master())

        if self.rank == mpi_master():
            grid_np_arrays = [arr for arr in grid_np_arrays if arr.size > 0]
            cubic_grid.set_values(np.vstack(grid_np_arrays).reshape(-1))

    def gen_cubes(self, cube_dict, molecule, basis, mol_orbs, density):
        """
        Computes and writes cube file.

        :param cube_dict:
            The dictionary of cube input.
        :param molecule:
            The molecule.
        :param basis:
            The AO basis set.
        :param mol_orbs:
            The molecular orbitals.
        :param density:
            The density matrix.
        """

        if 'grid' in cube_dict:
            grid_points = [
                int(x) for x in cube_dict['grid'].replace(',', ' ').split()
            ]
        else:
            grid_points = [80, 80, 80]
        cubic_grid = self.gen_cubic_grid(molecule, grid_points)

        cubes = [x.strip() for x in cube_dict['cubes'].split(',')]
        if 'files' in cube_dict:
            files = [x.strip() for x in cube_dict['files'].split(',')]
        else:
            files = ['cube_{:d}.cube'.format(i + 1) for i in range(len(cubes))]

        assert_msg_critical(
            len(cubes) == len(files),
            'VisualizationDriver: inconsistent number of cubes')

        for cube, fname in zip(cubes, files):

            m = re.search(r'^(.*)\((.*)\)$', cube)

            assert_msg_critical(
                m is not None,
                'VisualizationDriver: failed to read cube inputs')

            cube_type = m.group(1).strip().lower()

            if cube_type in ['mo', 'amo', 'bmo']:

                if cube_type in ['mo', 'amo']:
                    spin = 'alpha'
                    nelec = molecule.number_of_alpha_electrons()
                    mo_coefs = mol_orbs.alpha_to_numpy()
                else:
                    spin = 'beta'
                    nelec = molecule.number_of_beta_electrons()
                    mo_coefs = mol_orbs.beta_to_numpy()

                # Note: the input MO index should be 1-based
                cube_value = m.group(2).strip().lower()
                cube_value = cube_value.replace('homo', str(nelec))
                cube_value = cube_value.replace('lumo', str(nelec + 1))
                orb_id = eval(cube_value) - 1

                self.compute(cubic_grid, molecule, basis, mo_coefs, orb_id,
                             spin)

                if self.rank == mpi_master():
                    self.write_data(fname, cubic_grid, molecule, 'mo', orb_id,
                                    spin)

            elif cube_type == 'density':

                cube_value = m.group(2).strip().lower()
                spin = cube_value

                self.compute(cubic_grid, molecule, basis, density, 0, spin)

                if self.rank == mpi_master():
                    self.write_data(fname, cubic_grid, molecule, 'density', 0,
                                    spin)

    def get_atomic_orbital_info(self, *args):

        return self._vis_drv.get_atomic_orbital_info(*args)

    def map_atom_to_atomic_orbitals(self, *args):

        return self._vis_drv.map_atom_to_atomic_orbitals(*args)

    def compute_atomic_orbital_for_grid(self, *args):

        self._vis_drv.compute_atomic_orbital_for_grid(*args)

    def get_mo(self, *args):

        if self.rank == mpi_master():
            return self._vis_drv.get_mo(*args)
        else:
            return None

    def get_density(self, *args):

        if self.rank == mpi_master():
            return self._vis_drv.get_density(*args)
        else:
            return None

    def get_two_particle_density(self, *args):

        if self.rank == mpi_master():
            return self._vis_drv.get_two_particle_density(*args)
        else:
            return None
