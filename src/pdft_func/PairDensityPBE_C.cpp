//
//                              VELOXCHEM
//         ----------------------------------------------------
//                     An Electronic Structure Code
//
//  Copyright Â© 2018-2024 by VeloxChem developers. All rights reserved.
//
//  SPDX-License-Identifier: LGPL-3.0-or-later
//
//  This file is part of VeloxChem.
//
//  VeloxChem is free software: you can redistribute it and/or modify it under
//  the terms of the GNU Lesser General Public License as published by the Free
//  Software Foundation, either version 3 of the License, or (at your option)
//  any later version.
//
//  VeloxChem is distributed in the hope that it will be useful, but WITHOUT
//  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
//  License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with VeloxChem. If not, see <https://www.gnu.org/licenses/>.

#include "PairDensityPBE_C.hpp"

#include <algorithm>
#include <cmath>
#include <iostream>

#include "MathConst.hpp"

namespace pdftpbe_c {  // pdftpbe_c namespace

void
compute_exc_vxc(const int np, const double* rho, const double* sigma, double* exc, double* vrho, double* vsigma)
{

   // Subroutine generated by xc_write in MultiPsi, copyright M.G. Delcey, 2024

   double mbeta = 0.06672455060314922;

   double fz20 = 1.709921;

   double rsfact = 0.90856029641606983*pow(M_PI, -0.33333333333333331);

   double fpol = 1.0/(-2 + 2*cbrt(2));

   double mgamma = (1 - M_LN2)/pow(M_PI, 2);

   for (int g = 0; g < np; g++)
   {
      double density = rho[2 * g + 0];

      if (density < 1.0e-16)
      {
         exc[g] = 0.0;

         vrho[2 * g + 0] = 0.0;
         vrho[2 * g + 1] = 0.0;

         vsigma[3 * g + 0] = 0.0;
         vsigma[3 * g + 1] = 0.0;
         vsigma[3 * g + 2] = 0.0;

         continue;
      }

      double pair_density = rho[2 * g + 1];

      double sig = sigma[3 * g + 0];

      double zeta2 = -2*pair_density/pow(density, 2);

      double dzeta2_dpi = -2/pow(density, 2);

      double dzeta2_drho = 4*pair_density/pow(density, 3);

      double zeta4 = pow(zeta2, 2);

      double dzeta4_dzeta2 = 2*zeta2;

      double dzeta4_dpi = dzeta2_dpi*dzeta4_dzeta2;

      double dzeta4_drho = dzeta2_drho*dzeta4_dzeta2;

      double rs = rsfact/cbrt(density);

      double drs_drho = -1.0/3.0*rsfact/pow(density, 4.0/3.0);

      double gaux = 1.6382000000000001*pow(rs, 3.0/2.0) + 7.5956999999999999*sqrt(rs) + 0.49293999999999999*pow(rs, 2) + 3.5876000000000001*rs;

      double dgaux_drho = drs_drho*(2.4573*sqrt(rs) + 0.98587999999999998*rs + 3.5876000000000001 + 3.7978499999999999/sqrt(rs));

      double pw_g = -0.062182000000000001*(0.2137*rs + 1)*log(1 + 16.081824322151103/gaux);

      double dpw_g_drho = 0.99999999999999989*dgaux_drho*(0.2137*rs + 1)/(pow(gaux, 2)*(1 + 16.081824322151103/gaux)) - 0.0132882934*drs_drho*log(1 + 16.081824322151103/gaux);

      double g1 = pw_g;

      double dg1_drho = dpw_g_drho;

      double gaux_2 = 3.3662000000000001*pow(rs, 3.0/2.0) + 14.1189*sqrt(rs) + 0.62517*pow(rs, 2) + 6.1977000000000002*rs;

      double dgaux_2_drho = drs_drho*(5.0493000000000006*sqrt(rs) + 1.25034*rs + 6.1977000000000002 + 7.05945/sqrt(rs));

      double pw_g_2 = -0.03109*(0.20548*rs + 1)*log(1 + 32.1646831778707/gaux_2);

      double dpw_g_2_drho = 1.0*dgaux_2_drho*(0.20548*rs + 1)/(pow(gaux_2, 2)*(1 + 32.1646831778707/gaux_2)) - 0.0063883732000000002*drs_drho*log(1 + 32.1646831778707/gaux_2);

      double g2 = pw_g_2;

      double dg2_drho = dpw_g_2_drho;

      double gaux_3 = 0.88026000000000004*pow(rs, 3.0/2.0) + 10.356999999999999*sqrt(rs) + 0.49670999999999998*pow(rs, 2) + 3.6231*rs;

      double dgaux_3_drho = drs_drho*(1.3203900000000002*sqrt(rs) + 0.99341999999999997*rs + 3.6231 + 5.1784999999999997/sqrt(rs));

      double pw_g_3 = -0.033773999999999998*(0.11125*rs + 1)*log(1 + 29.608574643216677/gaux_3);

      double dpw_g_3_drho = 1.0*dgaux_3_drho*(0.11125*rs + 1)/(pow(gaux_3, 2)*(1 + 29.608574643216677/gaux_3)) - 0.0037573575*drs_drho*log(1 + 29.608574643216677/gaux_3);

      double g3 = pw_g_3;

      double dg3_drho = dpw_g_3_drho;

      double fzeta = 0;

      double dfzeta_drho = 0;

      double dfzeta_dpi = 0;

      if (pair_density < -9.9999999999999998e-17)
      {
         double zeta = M_SQRT2*sqrt(-pair_density)/density;

         double dzeta_dpi = (1.0/2.0)*M_SQRT2*sqrt(-pair_density)/(density*pair_density);

         double dzeta_drho = -M_SQRT2*sqrt(-pair_density)/pow(density, 2);

         double dfzeta_dzeta = 0.0;

         if (1.0 - zeta > 1.0e-16)
         {
             fzeta = pow(1.0 - zeta, 4.0/3.0) + pow(zeta + 1.0, 4.0/3.0);

             dfzeta_dzeta = -4.0/3.0*cbrt(1.0 - zeta) + (4.0/3.0)*cbrt(zeta + 1.0);
         }
         else
         {
             fzeta = pow(zeta + 1.0, 4.0/3.0);

             dfzeta_dzeta = (4.0/3.0)*cbrt(zeta + 1.0);
         }

         dfzeta_dpi = dfzeta_dzeta*dzeta_dpi;

         dfzeta_drho = dfzeta_dzeta*dzeta_drho;

      }
      else if (pair_density < 9.9999999999999998e-17)
      {
         fzeta = (10.0/243.0)*pow(zeta2, 2) + (4.0/9.0)*zeta2 + 2.0;

         double dfzeta_dzeta2 = (20.0/243.0)*zeta2 + 4.0/9.0;

         dfzeta_dpi = dfzeta_dzeta2*dzeta2_dpi;

         dfzeta_drho = dfzeta_dzeta2*dzeta2_drho;

      }
      else
      {
         double eta = M_SQRT2*sqrt(pair_density)/density;

         double deta_dpi = (1.0/2.0)*M_SQRT2/(density*sqrt(pair_density));

         double deta_drho = -M_SQRT2*sqrt(pair_density)/pow(density, 2);

         double theta = (4.0/3.0)*atan(eta);

         double dtheta_deta = (4.0/3.0)/(pow(eta, 2) + 1);

         double dtheta_dpi = deta_dpi*dtheta_deta;

         double dtheta_drho = deta_drho*dtheta_deta;

         fzeta = 2.0*pow(pow(eta, 2) + 1, 2.0/3.0)*cos(theta);

         double dfzeta_dtheta = -2.0*pow(pow(eta, 2) + 1, 2.0/3.0)*sin(theta);

         double dfzeta_deta = 2.6666666666666665*eta*cos(theta)/cbrt(pow(eta, 2) + 1);

         dfzeta_dpi = deta_dpi*dfzeta_deta + dfzeta_dtheta*dtheta_dpi;

         dfzeta_drho = deta_drho*dfzeta_deta + dfzeta_dtheta*dtheta_drho;

      }
      double epw92 = fpol*zeta4*(fzeta - 2)*(-g1 + g2 + g3/fz20) - fpol*g3*(fzeta - 2)/fz20 + g1;

      double depw92_dzeta4 = fpol*(fzeta - 2)*(-g1 + g2 + g3/fz20);

      double depw92_dfzeta = fpol*zeta4*(-g1 + g2 + g3/fz20) - fpol*g3/fz20;

      double depw92_dpi = depw92_dfzeta*dfzeta_dpi + depw92_dzeta4*dzeta4_dpi;

      double depw92_drho = depw92_dfzeta*dfzeta_drho + depw92_dzeta4*dzeta4_drho + dg1_drho*(-fpol*zeta4*(fzeta - 2) + 1) + dg2_drho*fpol*zeta4*(fzeta - 2) + dg3_drho*(fpol*zeta4*(fzeta - 2)/fz20 - fpol*(fzeta - 2)/fz20);

      double ec_lda = epw92;

      double dec_lda_depw92 = 1;

      double dec_lda_dpi = dec_lda_depw92*depw92_dpi;

      double dec_lda_drho = dec_lda_depw92*depw92_drho;

      double fzeta_2 = 0;

      double dfzeta_2_drho = 0;

      double dfzeta_2_dpi = 0;

      if (pair_density < -9.9999999999999998e-17)
      {
         double zeta = M_SQRT2*sqrt(-pair_density)/density;

         double dzeta_dpi = (1.0/2.0)*M_SQRT2*sqrt(-pair_density)/(density*pair_density);

         double dzeta_drho = -M_SQRT2*sqrt(-pair_density)/pow(density, 2);

         double dfzeta_2_dzeta = 0.0;

         if (1.0 - zeta > 1.0e-16)
         {
             fzeta_2 = pow(1.0 - zeta, 2.0/3.0) + pow(zeta + 1.0, 2.0/3.0);

             dfzeta_2_dzeta = (2.0/3.0)/cbrt(zeta + 1.0) - (2.0/3.0)/cbrt(1.0 - zeta);
         }
         else
         {
             fzeta_2 = pow(zeta + 1.0, 2.0/3.0);

             dfzeta_2_dzeta = (2.0/3.0)/cbrt(zeta + 1.0);
         }

         dfzeta_2_dpi = dfzeta_2_dzeta*dzeta_dpi;

         dfzeta_2_drho = dfzeta_2_dzeta*dzeta_drho;

      }
      else if (pair_density < 9.9999999999999998e-17)
      {
         fzeta_2 = -14.0/243.0*pow(zeta2, 2) - 2.0/9.0*zeta2 + 2.0;

         double dfzeta_2_dzeta2 = -28.0/243.0*zeta2 - 2.0/9.0;

         dfzeta_2_dpi = dfzeta_2_dzeta2*dzeta2_dpi;

         dfzeta_2_drho = dfzeta_2_dzeta2*dzeta2_drho;

      }
      else
      {
         double eta = M_SQRT2*sqrt(pair_density)/density;

         double deta_dpi = (1.0/2.0)*M_SQRT2/(density*sqrt(pair_density));

         double deta_drho = -M_SQRT2*sqrt(pair_density)/pow(density, 2);

         double theta = (2.0/3.0)*atan(eta);

         double dtheta_deta = (2.0/3.0)/(pow(eta, 2) + 1);

         double dtheta_dpi = deta_dpi*dtheta_deta;

         double dtheta_drho = deta_drho*dtheta_deta;

         fzeta_2 = 2.0*cbrt(pow(eta, 2) + 1)*cos(theta);

         double dfzeta_2_dtheta = -2.0*cbrt(pow(eta, 2) + 1)*sin(theta);

         double dfzeta_2_deta = 1.3333333333333333*eta*cos(theta)/pow(pow(eta, 2) + 1, 2.0/3.0);

         dfzeta_2_dpi = deta_dpi*dfzeta_2_deta + dfzeta_2_dtheta*dtheta_dpi;

         dfzeta_2_drho = deta_drho*dfzeta_2_deta + dfzeta_2_dtheta*dtheta_drho;

      }
      double mphi = (1.0/2.0)*fzeta_2;

      double dmphi_dfzeta_2 = 1.0/2.0;

      double dmphi_dpi = dfzeta_2_dpi*dmphi_dfzeta_2;

      double dmphi_drho = dfzeta_2_drho*dmphi_dfzeta_2;

      double mphi3 = pow(mphi, 3);

      double dmphi3_dmphi = 3*pow(mphi, 2);

      double dmphi3_dpi = dmphi3_dmphi*dmphi_dpi;

      double dmphi3_drho = dmphi3_dmphi*dmphi_drho;

      double Aexp = -1 + exp(-epw92/(mgamma*mphi3));

      double dAexp_depw92 = -exp(-epw92/(mgamma*mphi3))/(mgamma*mphi3);

      double dAexp_dmphi3 = epw92*exp(-epw92/(mgamma*mphi3))/(mgamma*pow(mphi3, 2));

      double dAexp_dpi = dAexp_depw92*depw92_dpi + dAexp_dmphi3*dmphi3_dpi;

      double dAexp_drho = dAexp_depw92*depw92_drho + dAexp_dmphi3*dmphi3_drho;

      double A = mbeta/(Aexp*mgamma);

      double dA_dAexp = -mbeta/(pow(Aexp, 2)*mgamma);

      double dA_dpi = dA_dAexp*dAexp_dpi;

      double dA_drho = dA_dAexp*dAexp_drho;

      double xt = pow(density, -1.3333333333333333)*sqrt(sig);

      double dxt_dsig = (1.0/2.0)*pow(density, -1.3333333333333333)/sqrt(sig);

      double dxt_drho = -1.3333333333333333*pow(density, -2.333333333333333)*sqrt(sig);

      double t = (1.0/8.0)*pow(2, 2.0/3.0)*xt/(mphi*sqrt(rs));

      double dt_dmphi = -1.0/8.0*pow(2, 2.0/3.0)*xt/(pow(mphi, 2)*sqrt(rs));

      double dt_dxt = (1.0/8.0)*pow(2, 2.0/3.0)/(mphi*sqrt(rs));

      double dt_dpi = dmphi_dpi*dt_dmphi;

      double dt_dsig = dt_dxt*dxt_dsig;

      double dt_drho = dmphi_drho*dt_dmphi - 1.0/16.0*pow(2, 2.0/3.0)*drs_drho*xt/(mphi*pow(rs, 3.0/2.0)) + dt_dxt*dxt_drho;

      double f1 = A*pow(t, 4) + pow(t, 2);

      double df1_dt = 4*A*pow(t, 3) + 2*t;

      double df1_dA = pow(t, 4);

      double df1_dpi = dA_dpi*df1_dA + df1_dt*dt_dpi;

      double df1_dsig = df1_dt*dt_dsig;

      double df1_drho = dA_drho*df1_dA + df1_dt*dt_drho;

      double f2 = f1*mbeta/(mgamma*(A*f1 + 1));

      double df2_dA = -pow(f1, 2)*mbeta/(mgamma*pow(A*f1 + 1, 2));

      double df2_df1 = -A*f1*mbeta/(mgamma*pow(A*f1 + 1, 2)) + mbeta/(mgamma*(A*f1 + 1));

      double df2_dpi = dA_dpi*df2_dA + df1_dpi*df2_df1;

      double df2_dsig = df1_dsig*df2_df1;

      double df2_drho = dA_drho*df2_dA + df1_drho*df2_df1;

      double H = mgamma*mphi3*log(f2 + 1);

      double dH_dmphi3 = mgamma*log(f2 + 1);

      double dH_df2 = mgamma*mphi3/(f2 + 1);

      double dH_dpi = dH_df2*df2_dpi + dH_dmphi3*dmphi3_dpi;

      double dH_dsig = dH_df2*df2_dsig;

      double dH_drho = dH_df2*df2_drho + dH_dmphi3*dmphi3_drho;

      double ec_pbe = H + epw92;

      double dec_pbe_dH = 1;

      double dec_pbe_depw92 = 1;

      double dec_pbe_dpi = dH_dpi*dec_pbe_dH + dec_pbe_depw92*depw92_dpi;

      double dec_pbe_dsig = dH_dsig*dec_pbe_dH;

      double dec_pbe_drho = dH_drho*dec_pbe_dH + dec_pbe_depw92*depw92_drho;

      exc[g] =  ec_pbe;

      double dExc_dec_pbe = density;

      vrho[2 * g + 1] =  dExc_dec_pbe*dec_pbe_dpi;

      vsigma[3 * g + 0] =  dExc_dec_pbe*dec_pbe_dsig;

      vrho[2 * g + 0] =  dExc_dec_pbe*dec_pbe_drho + ec_pbe;

      //Currently, no explicit dependence
      vsigma[3 * g + 1] = 0.0;
      vsigma[3 * g + 2] = 0.0;

   }
}

}  // namespace pdftpbe_c
