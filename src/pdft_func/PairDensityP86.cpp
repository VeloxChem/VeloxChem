//
//                                   VELOXCHEM
//              ----------------------------------------------------
//                          An Electronic Structure Code
//
//  SPDX-License-Identifier: BSD-3-Clause
//
//  Copyright 2018-2025 VeloxChem developers
//
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//
//  1. Redistributions of source code must retain the above copyright notice, this
//     list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//  3. Neither the name of the copyright holder nor the names of its contributors
//     may be used to endorse or promote products derived from this software without
//     specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
//  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "PairDensityP86.hpp"

#include <algorithm>
#include <cmath>
#include <iostream>

#include "MathConst.hpp"

namespace pdftp86 {  // pdftp86 namespace

void
compute_exc_vxc(const int np, const double* rho, const double* sigma, double* exc, double* vrho, double* vsigma)
{

   // Subroutine generated by xc_write in MultiPsi, copyright M.G. Delcey, 2024

   double rsfact = 0.90856029641606983*pow(M_PI, -0.33333333333333331);

   double ccinf = 0.004235;

   double fpol = 1.0/(-2 + 2*cbrt(2));

   for (int g = 0; g < np; g++)
   {
      double density = rho[2 * g + 0];

      if (density < 1.0e-16)
      {
         exc[g] = 0.0;

         vrho[2 * g + 0] = 0.0;
         vrho[2 * g + 1] = 0.0;

         vsigma[3 * g + 0] = 0.0;
         vsigma[3 * g + 1] = 0.0;
         vsigma[3 * g + 2] = 0.0;

         continue;
      }

      double pair_density = rho[2 * g + 1];

      double sig = sigma[3 * g + 0];

      double rs = rsfact/cbrt(density);

      double drs_drho = -1.0/3.0*rsfact/pow(density, 4.0/3.0);

      double rs2 = pow(rs, 2);

      double drs2_drho = 2*drs_drho*rs;

      double dfzeta_dpi = 0;

      double fzeta = 0;

      double dfzeta_drho = 0;

      if (pair_density < -9.9999999999999998e-17)
      {
         double zeta = M_SQRT2*sqrt(-pair_density)/density;

         double dzeta_drho = -M_SQRT2*sqrt(-pair_density)/pow(density, 2);

         double dzeta_dpi = (1.0/2.0)*M_SQRT2*sqrt(-pair_density)/(density*pair_density);

         double dfzeta_dzeta = 0.0;

         if (1-zeta > 1.0e-16)
         {
             fzeta = pow(1.0 - zeta, 5.0/3.0) + pow(zeta + 1.0, 5.0/3.0);

             dfzeta_dzeta = -5.0/3.0*pow(1.0 - zeta, 2.0/3.0) + (5.0/3.0)*pow(zeta + 1.0, 2.0/3.0);
         }
         else
         {
             fzeta = pow(zeta + 1.0, 5.0/3.0);

             dfzeta_dzeta = (5.0/3.0)*pow(zeta + 1.0, 2.0/3.0);
         }

         dfzeta_drho = dfzeta_dzeta*dzeta_drho;

         dfzeta_dpi = dfzeta_dzeta*dzeta_dpi;

      }
      else if (pair_density < 9.9999999999999998e-17)
      {
         double zeta2 = -2*pair_density/pow(density, 2);

         double dzeta2_drho = 4*pair_density/pow(density, 3);

         double dzeta2_dpi = -2/pow(density, 2);

         fzeta = (10.0/243.0)*pow(zeta2, 2) + (10.0/9.0)*zeta2 + 2.0;

         double dfzeta_dzeta2 = (20.0/243.0)*zeta2 + 10.0/9.0;

         dfzeta_drho = dfzeta_dzeta2*dzeta2_drho;

         dfzeta_dpi = dfzeta_dzeta2*dzeta2_dpi;

      }
      else
      {
         double eta = M_SQRT2*sqrt(pair_density)/density;

         double deta_drho = -M_SQRT2*sqrt(pair_density)/pow(density, 2);

         double deta_dpi = (1.0/2.0)*M_SQRT2/(density*sqrt(pair_density));

         double theta = (5.0/3.0)*atan(eta);

         double dtheta_deta = (5.0/3.0)/(pow(eta, 2) + 1);

         double dtheta_drho = deta_drho*dtheta_deta;

         double dtheta_dpi = deta_dpi*dtheta_deta;

         fzeta = 2.0*pow(pow(eta, 2) + 1, 5.0/6.0)*cos(theta);

         double dfzeta_deta = 3.3333333333333335*eta*cos(theta)/pow(pow(eta, 2) + 1, 1.0/6.0);

         double dfzeta_dtheta = -2.0*pow(pow(eta, 2) + 1, 5.0/6.0)*sin(theta);

         dfzeta_drho = deta_drho*dfzeta_deta + dfzeta_dtheta*dtheta_drho;

         dfzeta_dpi = deta_dpi*dfzeta_deta + dfzeta_dtheta*dtheta_dpi;

      }
      double dd = (1.0/2.0)*M_SQRT2*sqrt(fzeta);

      double ddd_dfzeta = (1.0/4.0)*M_SQRT2/sqrt(fzeta);

      double ddd_drho = ddd_dfzeta*dfzeta_drho;

      double ddd_dpi = ddd_dfzeta*dfzeta_dpi;

      double cc = (0.023265999999999998*rs + 7.3889999999999999e-6*rs2 + 0.002568)/(0.073889999999999997*pow(rs, 3) + 8.7230000000000008*rs + 0.47199999999999998*rs2 + 1) + 0.0016670000000000001;

      double dcc_drho = drs2_drho*(-0.0062031210135994339*(0.023265999999999998*rs + 7.3889999999999999e-6*rs2 + 0.002568)/pow(0.0084707096182506016*pow(rs, 3) + rs + 0.054109824601627873*rs2 + 0.11463945890175398, 2) + 7.3889999999999999e-6/(0.073889999999999997*pow(rs, 3) + 8.7230000000000008*rs + 0.47199999999999998*rs2 + 1)) + drs_drho*(0.013142205537286938*(-0.22166999999999998*pow(rs, 2) - 8.7230000000000008)*(0.023265999999999998*rs + 7.3889999999999999e-6*rs2 + 0.002568)/pow(0.0084707096182506016*pow(rs, 3) + rs + 0.054109824601627873*rs2 + 0.11463945890175398, 2) + 0.023265999999999998/(0.073889999999999997*pow(rs, 3) + 8.7230000000000008*rs + 0.47199999999999998*rs2 + 1));

      double xt = pow(density, -1.3333333333333333)*sqrt(sig);

      double dxt_drho = -1.3333333333333333*pow(density, -2.333333333333333)*sqrt(sig);

      double dxt_dsig = (1.0/2.0)*pow(density, -1.3333333333333333)/sqrt(sig);

      double x1 = xt/sqrt(rs/rsfact);

      double dx1_dxt = pow(rs/rsfact, -1.0/2.0);

      double dx1_drho = -1.0/2.0*drs_drho*xt/(rs*sqrt(rs/rsfact)) + dx1_dxt*dxt_drho;

      double dx1_dsig = dx1_dxt*dxt_dsig;

      double mphi = 0.19195000000000001*ccinf*x1/cc;

      double dmphi_dx1 = 0.19195000000000001*ccinf/cc;

      double dmphi_drho = dmphi_dx1*dx1_drho - 0.19195000000000001*ccinf*dcc_drho*x1/pow(cc, 2);

      double dmphi_dsig = dmphi_dx1*dx1_dsig;

      double p86_H = cc*pow(x1, 2)*exp(-mphi)/dd;

      double dp86_H_dx1 = 2*cc*x1*exp(-mphi)/dd;

      double dp86_H_dmphi = -cc*pow(x1, 2)*exp(-mphi)/dd;

      double dp86_H_ddd = -cc*pow(x1, 2)*exp(-mphi)/pow(dd, 2);

      double dp86_H_drho = dcc_drho*pow(x1, 2)*exp(-mphi)/dd + ddd_drho*dp86_H_ddd + dmphi_drho*dp86_H_dmphi + dp86_H_dx1*dx1_drho;

      double dp86_H_dpi = ddd_dpi*dp86_H_ddd;

      double dp86_H_dsig = dmphi_dsig*dp86_H_dmphi + dp86_H_dx1*dx1_dsig;

      double dec2_drho = 0;

      double ec1 = 0;

      double dec1_drho = 0;

      double ec2 = 0;

      if (rs >= 1)
      {
         ec1 = -0.14230000000000001/(1.0528999999999999*sqrt(rs) + 0.33339999999999997*rs + 1);

         dec1_drho = -0.12836027791163801*drs_drho*(-0.33339999999999997 - 0.52644999999999997/sqrt(rs))/pow(sqrt(rs) + 0.31664925444011777*rs + 0.94975781175800178, 2);

         ec2 = -0.0843/(1.3980999999999999*sqrt(rs) + 0.2611*rs + 1);

         dec2_drho = -0.043127184148231551*drs_drho*(-0.2611 - 0.69904999999999995/sqrt(rs))/pow(sqrt(rs) + 0.18675345111222375*rs + 0.71525641942636442, 2);

      }
      else
      {
         ec1 = 0.002*rs*log(rs) - 0.011599999999999999*rs + 0.031099999999999999*log(rs) - 0.048000000000000001;

         dec1_drho = drs_drho*(0.002*log(rs) - 0.0095999999999999992 + 0.031099999999999999/rs);

         ec2 = 0.00069999999999999999*rs*log(rs) - 0.0047999999999999996*rs + 0.01555*log(rs) - 0.0269;

         dec2_drho = drs_drho*(0.00069999999999999999*log(rs) - 0.0040999999999999995 + 0.01555/rs);

      }
      double fzeta_2 = 0;

      double dfzeta_2_drho = 0;

      double dfzeta_2_dpi = 0;

      if (pair_density < -9.9999999999999998e-17)
      {
         double zeta = M_SQRT2*sqrt(-pair_density)/density;

         double dzeta_drho = -M_SQRT2*sqrt(-pair_density)/pow(density, 2);

         double dzeta_dpi = (1.0/2.0)*M_SQRT2*sqrt(-pair_density)/(density*pair_density);

         double dfzeta_2_dzeta = 0.0;

         if (1-zeta > 1.0e-16)
         {
             fzeta_2 = pow(1.0 - zeta, 4.0/3.0) + pow(zeta + 1.0, 4.0/3.0);

             dfzeta_2_dzeta = -4.0/3.0*cbrt(1.0 - zeta) + (4.0/3.0)*cbrt(zeta + 1.0);
         }
         else
         {
             fzeta_2 = pow(zeta + 1.0, 4.0/3.0);

             dfzeta_2_dzeta = (4.0/3.0)*cbrt(zeta + 1.0);
         }

         dfzeta_2_drho = dfzeta_2_dzeta*dzeta_drho;

         dfzeta_2_dpi = dfzeta_2_dzeta*dzeta_dpi;

      }
      else if (pair_density < 9.9999999999999998e-17)
      {
         double zeta2 = -2*pair_density/pow(density, 2);

         double dzeta2_drho = 4*pair_density/pow(density, 3);

         double dzeta2_dpi = -2/pow(density, 2);

         fzeta_2 = (10.0/243.0)*pow(zeta2, 2) + (4.0/9.0)*zeta2 + 2.0;

         double dfzeta_2_dzeta2 = (20.0/243.0)*zeta2 + 4.0/9.0;

         dfzeta_2_drho = dfzeta_2_dzeta2*dzeta2_drho;

         dfzeta_2_dpi = dfzeta_2_dzeta2*dzeta2_dpi;

      }
      else
      {
         double eta = M_SQRT2*sqrt(pair_density)/density;

         double deta_drho = -M_SQRT2*sqrt(pair_density)/pow(density, 2);

         double deta_dpi = (1.0/2.0)*M_SQRT2/(density*sqrt(pair_density));

         double theta = (4.0/3.0)*atan(eta);

         double dtheta_deta = (4.0/3.0)/(pow(eta, 2) + 1);

         double dtheta_drho = deta_drho*dtheta_deta;

         double dtheta_dpi = deta_dpi*dtheta_deta;

         fzeta_2 = 2.0*pow(pow(eta, 2) + 1, 2.0/3.0)*cos(theta);

         double dfzeta_2_deta = 2.6666666666666665*eta*cos(theta)/cbrt(pow(eta, 2) + 1);

         double dfzeta_2_dtheta = -2.0*pow(pow(eta, 2) + 1, 2.0/3.0)*sin(theta);

         dfzeta_2_drho = deta_drho*dfzeta_2_deta + dfzeta_2_dtheta*dtheta_drho;

         dfzeta_2_dpi = deta_dpi*dfzeta_2_deta + dfzeta_2_dtheta*dtheta_dpi;

      }
      double epz = ec1 + fpol*(ec1 + ec2)*(fzeta_2 - 2);

      double depz_dfzeta_2 = fpol*(ec1 + ec2);

      double depz_drho = dec1_drho*(fpol*(fzeta_2 - 2) + 1) + dec2_drho*fpol*(fzeta_2 - 2) + depz_dfzeta_2*dfzeta_2_drho;

      double depz_dpi = depz_dfzeta_2*dfzeta_2_dpi;

      double ep86 = epz + p86_H;

      double dep86_depz = 1;

      double dep86_dp86_H = 1;

      double dep86_drho = dep86_depz*depz_drho + dep86_dp86_H*dp86_H_drho;

      double dep86_dpi = dep86_depz*depz_dpi + dep86_dp86_H*dp86_H_dpi;

      double dep86_dsig = dep86_dp86_H*dp86_H_dsig;

      exc[g] =  ep86;

      double dExc_dep86 = density;

      vrho[2 * g + 0] =  dExc_dep86*dep86_drho + ep86;

      vrho[2 * g + 1] =  dExc_dep86*dep86_dpi;

      vsigma[3 * g + 0] =  dExc_dep86*dep86_dsig;

      //Currently, no explicit dependence
      vsigma[3 * g + 1] = 0.0;
      vsigma[3 * g + 2] = 0.0;

   }
}

}  // namespace pdftp86_c
