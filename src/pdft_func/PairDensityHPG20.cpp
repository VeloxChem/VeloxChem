//
//                                   VELOXCHEM
//              ----------------------------------------------------
//                          An Electronic Structure Code
//
//  SPDX-License-Identifier: BSD-3-Clause
//
//  Copyright 2018-2025 VeloxChem developers
//
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//
//  1. Redistributions of source code must retain the above copyright notice, this
//     list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//  3. Neither the name of the copyright holder nor the names of its contributors
//     may be used to endorse or promote products derived from this software without
//     specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
//  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "PairDensityHPG20.hpp"

#include <algorithm>
#include <cmath>
#include <iostream>

#include "MathConst.hpp"

namespace pdfthpg20 {  // pdfthpg20 namespace

void
compute_exc_vxc(const int np, const double* rho, const double* sigma, double* exc, double* vrho, double* vsigma)
{

   // Subroutine generated by xc_write in MultiPsi, copyright M.G. Delcey, 2024

   double lyp_a = 0.049180000000000001;

   double lyp_b = 0.13200000000000001;

   double lyp_c = 0.25330000000000003;

   double lyp_d = 0.34899999999999998;

   double lyp_cf = (3.0/10.0)*pow(3, 2.0/3.0)*pow(M_PI, 4.0/3.0);

   double lyp_aux6 = (1.0/8.0)*cbrt(2);

   double lyp_aux4 = (1.0/4.0)*lyp_aux6;

   double lyp_aux5 = (1.0/18.0)*lyp_aux4;

   double hpg20_a = 0.191856;

   double hpg20_b = -0.81488899999999997;

   double hpg20_c = 2.5664799999999999;

   double hpg20_d = 6.3151469999999996;

   double hpg20_g = 1.501069;

   for (int g = 0; g < np; g++)
   {
      double density = rho[2 * g + 0];

      if (density < 1.0e-16)
      {
         exc[g] = 0.0;

         vrho[2 * g + 0] = 0.0;
         vrho[2 * g + 1] = 0.0;

         vsigma[3 * g + 0] = 0.0;
         vsigma[3 * g + 1] = 0.0;
         vsigma[3 * g + 2] = 0.0;

         continue;
      }

      double pair_density = rho[2 * g + 1];

      double sig = sigma[3 * g + 0];

      double rr = pow(density, -1.0/3.0);

      double drr_drho = -(1.0/3.0)/pow(density, 4.0/3.0);

      double lyp_omega = lyp_b*exp(-lyp_c*rr)/(lyp_d*rr + 1);

      double dlyp_omega_drho = drr_drho*(-lyp_b*lyp_c*exp(-lyp_c*rr)/(lyp_d*rr + 1) - lyp_b*lyp_d*exp(-lyp_c*rr)/pow(lyp_d*rr + 1, 2));

      double lyp_delta = rr*(lyp_c + lyp_d/(lyp_d*rr + 1));

      double dlyp_delta_drho = drr_drho*(lyp_c - pow(lyp_d, 2)*rr/pow(lyp_d*rr + 1, 2) + lyp_d/(lyp_d*rr + 1));

      double lyp_t1 = -1/(lyp_d*rr + 1);

      double dlyp_t1_drho = drr_drho*lyp_d/pow(lyp_d*rr + 1, 2);

      double xt2 = pow(density, -2.6666666666666665)*sig;

      double dxt2_drho = -2.6666666666666665*pow(density, -3.6666666666666665)*sig;

      double dxt2_dsig = pow(density, -2.6666666666666665);

      double lyp_t2 = -xt2*(-7.0/72.0*lyp_delta - 1.0/72.0);

      double dlyp_t2_dxt2 = (7.0/72.0)*lyp_delta + 1.0/72.0;

      double dlyp_t2_drho = (7.0/72.0)*dlyp_delta_drho*xt2 + dlyp_t2_dxt2*dxt2_drho;

      double dlyp_t2_dsig = dlyp_t2_dxt2*dxt2_dsig;

      double xt = pow(density, -1.3333333333333333)*sqrt(sig);

      double dxt_drho = -1.3333333333333333*pow(density, -2.333333333333333)*sqrt(sig);

      double dxt_dsig = (1.0/2.0)*pow(density, -1.3333333333333333)/sqrt(sig);

      double lyp_t4 = 2*pow(2, 2.0/3.0)*lyp_aux4*pow(xt, 2)*(5.0/2.0 - 1.0/18.0*lyp_delta);

      double dlyp_t4_dxt = 4*pow(2, 2.0/3.0)*lyp_aux4*xt*(5.0/2.0 - 1.0/18.0*lyp_delta);

      double dlyp_t4_drho = -1.0/9.0*pow(2, 2.0/3.0)*dlyp_delta_drho*lyp_aux4*pow(xt, 2) + dlyp_t4_dxt*dxt_drho;

      double dlyp_t4_dsig = dlyp_t4_dxt*dxt_dsig;

      double lyp_t5 = 2*pow(2, 2.0/3.0)*lyp_aux5*pow(xt, 2)*(lyp_delta - 11);

      double dlyp_t5_dxt = 4*pow(2, 2.0/3.0)*lyp_aux5*xt*(lyp_delta - 11);

      double dlyp_t5_drho = 2*pow(2, 2.0/3.0)*dlyp_delta_drho*lyp_aux5*pow(xt, 2) + dlyp_t5_dxt*dxt_drho;

      double dlyp_t5_dsig = dlyp_t5_dxt*dxt_dsig;

      double lyp_t6 = -5.0/6.0*pow(2, 2.0/3.0)*lyp_aux6*xt2;

      double dlyp_t6_dxt2 = -5.0/6.0*pow(2, 2.0/3.0)*lyp_aux6;

      double dlyp_t6_dsig = dlyp_t6_dxt2*dxt2_dsig;

      double dlyp_t6_drho = dlyp_t6_dxt2*dxt2_drho;

      double lyp_nopol = lyp_a*(lyp_omega*(-lyp_cf + lyp_t2 + lyp_t4 + lyp_t5 + lyp_t6) + lyp_t1);

      double dlyp_nopol_dlyp_t6 = lyp_a*lyp_omega;

      double dlyp_nopol_dlyp_t5 = lyp_a*lyp_omega;

      double dlyp_nopol_dlyp_t4 = lyp_a*lyp_omega;

      double dlyp_nopol_dlyp_t2 = lyp_a*lyp_omega;

      double dlyp_nopol_drho = dlyp_nopol_dlyp_t2*dlyp_t2_drho + dlyp_nopol_dlyp_t4*dlyp_t4_drho + dlyp_nopol_dlyp_t5*dlyp_t5_drho + dlyp_nopol_dlyp_t6*dlyp_t6_drho + dlyp_omega_drho*lyp_a*(-lyp_cf + lyp_t2 + lyp_t4 + lyp_t5 + lyp_t6) + dlyp_t1_drho*lyp_a;

      double dlyp_nopol_dsig = dlyp_nopol_dlyp_t2*dlyp_t2_dsig + dlyp_nopol_dlyp_t4*dlyp_t4_dsig + dlyp_nopol_dlyp_t5*dlyp_t5_dsig + dlyp_nopol_dlyp_t6*dlyp_t6_dsig;

      double zeta2 = -2*pair_density/pow(density, 2);

      double dzeta2_drho = 4*pair_density/pow(density, 3);

      double dzeta2_dpi = -2/pow(density, 2);

      double x = -zeta2 + 1;

      double dx_dzeta2 = -1;

      double dx_drho = dx_dzeta2*dzeta2_drho;

      double dx_dpi = dx_dzeta2*dzeta2_dpi;

      double dpol_drho = 0;

      double pol = 0;

      double dpol_dpi = 0;

      double dpol_dx = 0;

      if (x <= 1)
      {
         pol = hpg20_a*x/(hpg20_b*x + 1);

         dpol_dx = -hpg20_a*hpg20_b*x/pow(hpg20_b*x + 1, 2) + hpg20_a/(hpg20_b*x + 1);

         dpol_drho = dpol_dx*dx_drho;

         dpol_dpi = dpol_dx*dx_dpi;

      }
      else
      {
         pol = hpg20_c*pow(x, 1.0/4.0) - hpg20_d*pow(-hpg20_g + x, 2);

         dpol_dx = (1.0/4.0)*hpg20_c/pow(x, 3.0/4.0) - hpg20_d*(-2*hpg20_g + 2*x);

         dpol_drho = dpol_dx*dx_drho;

         dpol_dpi = dpol_dx*dx_dpi;

      }

      exc[g] =  lyp_nopol*pol;

      double dExc_dlyp_nopol = density*pol;

      double dExc_dpol = density*lyp_nopol;

      vrho[2 * g + 0] =  dExc_dlyp_nopol*dlyp_nopol_drho + dExc_dpol*dpol_drho + lyp_nopol*pol;

      vsigma[3 * g + 0] =  dExc_dlyp_nopol*dlyp_nopol_dsig;

      vrho[2 * g + 1] =  dExc_dpol*dpol_dpi;

      //Currently, no explicit dependence
      vsigma[3 * g + 1] = 0.0;
      vsigma[3 * g + 2] = 0.0;

   }
}
}  // namespace pdfthpg20
