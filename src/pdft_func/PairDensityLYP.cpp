//
//                                   VELOXCHEM
//              ----------------------------------------------------
//                          An Electronic Structure Code
//
//  SPDX-License-Identifier: BSD-3-Clause
//
//  Copyright 2018-2025 VeloxChem developers
//
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//
//  1. Redistributions of source code must retain the above copyright notice, this
//     list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//  3. Neither the name of the copyright holder nor the names of its contributors
//     may be used to endorse or promote products derived from this software without
//     specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
//  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "PairDensityLYP.hpp"

#include <algorithm>
#include <cmath>
#include <iostream>

#include "MathConst.hpp"

namespace pdftlyp {  // pdftlyp namespace

void
compute_exc_vxc(const int np, const double* rho, const double* sigma, double* exc, double* vrho, double* vsigma)
{

   // Subroutine generated by xc_write in MultiPsi, copyright M.G. Delcey, 2024

   double lyp_a = 0.049180000000000001;

   double lyp_b = 0.13200000000000001;

   double lyp_c = 0.25330000000000003;

   double lyp_d = 0.34899999999999998;

   double lyp_cf = (3.0/10.0)*pow(3, 2.0/3.0)*pow(M_PI, 4.0/3.0);

   double lyp_aux6 = (1.0/8.0)*cbrt(2);

   double lyp_aux4 = (1.0/4.0)*lyp_aux6;

   double lyp_aux5 = (1.0/18.0)*lyp_aux4;

   for (int g = 0; g < np; g++)
   {
      double density = rho[2 * g + 0];

      if (density < 1.0e-16)
      {
         exc[g] = 0.0;

         vrho[2 * g + 0] = 0.0;
         vrho[2 * g + 1] = 0.0;

         vsigma[3 * g + 0] = 0.0;
         vsigma[3 * g + 1] = 0.0;
         vsigma[3 * g + 2] = 0.0;

         continue;
      }

      double pair_density = rho[2 * g + 1];

      double sig = sigma[3 * g + 0];

      double rr = pow(density, -1.0/3.0);

      double drr_drho = -(1.0/3.0)/pow(density, 4.0/3.0);

      double lyp_omega = lyp_b*exp(-lyp_c*rr)/(lyp_d*rr + 1);

      double dlyp_omega_drho = drr_drho*(-lyp_b*lyp_c*exp(-lyp_c*rr)/(lyp_d*rr + 1) - lyp_b*lyp_d*exp(-lyp_c*rr)/pow(lyp_d*rr + 1, 2));

      double lyp_delta = rr*(lyp_c + lyp_d/(lyp_d*rr + 1));

      double dlyp_delta_drho = drr_drho*(lyp_c - pow(lyp_d, 2)*rr/pow(lyp_d*rr + 1, 2) + lyp_d/(lyp_d*rr + 1));

      double zeta2 = -2*pair_density/pow(density, 2);

      double dzeta2_dpi = -2/pow(density, 2);

      double dzeta2_drho = 4*pair_density/pow(density, 3);

      double lyp_t1 = (zeta2 - 1)/(lyp_d*rr + 1);

      double dlyp_t1_dzeta2 = 1.0/(lyp_d*rr + 1);

      double dlyp_t1_dpi = dlyp_t1_dzeta2*dzeta2_dpi;

      double dlyp_t1_drho = dlyp_t1_dzeta2*dzeta2_drho - drr_drho*lyp_d*(zeta2 - 1)/pow(lyp_d*rr + 1, 2);

      double xt2 = pow(density, -2.6666666666666665)*sig;

      double dxt2_dsig = pow(density, -2.6666666666666665);

      double dxt2_drho = -2.6666666666666665*pow(density, -3.6666666666666665)*sig;

      double lyp_t2 = -xt2*((1.0/72.0)*(1 - zeta2)*(47 - 7*lyp_delta) - 2.0/3.0);

      double dlyp_t2_dzeta2 = -xt2*((7.0/72.0)*lyp_delta - 47.0/72.0);

      double dlyp_t2_dxt2 = -1.0/72.0*(1 - zeta2)*(47 - 7*lyp_delta) + 2.0/3.0;

      double dlyp_t2_dpi = dlyp_t2_dzeta2*dzeta2_dpi;

      double dlyp_t2_dsig = dlyp_t2_dxt2*dxt2_dsig;

      double dlyp_t2_drho = -dlyp_delta_drho*xt2*((7.0/72.0)*zeta2 - 7.0/72.0) + dlyp_t2_dxt2*dxt2_drho + dlyp_t2_dzeta2*dzeta2_drho;

      double dfzeta_dpi = 0;

      double fzeta = 0;

      double dfzeta_drho = 0;

      if (pair_density < -9.9999999999999998e-17)
      {
         double zeta = M_SQRT2*sqrt(-pair_density)/density;

         double dzeta_dpi = (1.0/2.0)*M_SQRT2*sqrt(-pair_density)/(density*pair_density);

         double dzeta_drho = -M_SQRT2*sqrt(-pair_density)/pow(density, 2);

         double dfzeta_dzeta = 0.0;

         if (1.0 - zeta > 1.0e-16)
         {
             fzeta = pow(1.0 - zeta, 8.0/3.0) + pow(zeta + 1.0, 8.0/3.0);

             dfzeta_dzeta = -8.0/3.0*pow(1.0 - zeta, 5.0/3.0) + (8.0/3.0)*pow(zeta + 1.0, 5.0/3.0);
         }
         else
         {
             fzeta = pow(zeta + 1.0, 8.0/3.0);

             dfzeta_dzeta = (8.0/3.0)*pow(zeta + 1.0, 5.0/3.0);
         }

         dfzeta_dpi = dfzeta_dzeta*dzeta_dpi;

         dfzeta_drho = dfzeta_dzeta*dzeta_drho;

      }
      else if (pair_density < 9.9999999999999998e-17)
      {
         fzeta = -20.0/243.0*pow(zeta2, 2) + (40.0/9.0)*zeta2 + 2.0;

         double dfzeta_dzeta2 = 40.0/9.0 - 40.0/243.0*zeta2;

         dfzeta_dpi = dfzeta_dzeta2*dzeta2_dpi;

         dfzeta_drho = dfzeta_dzeta2*dzeta2_drho;

      }
      else
      {
         double eta = M_SQRT2*sqrt(pair_density)/density;

         double deta_dpi = (1.0/2.0)*M_SQRT2/(density*sqrt(pair_density));

         double deta_drho = -M_SQRT2*sqrt(pair_density)/pow(density, 2);

         double theta = (8.0/3.0)*atan(eta);

         double dtheta_deta = (8.0/3.0)/(pow(eta, 2) + 1);

         double dtheta_dpi = deta_dpi*dtheta_deta;

         double dtheta_drho = deta_drho*dtheta_deta;

         fzeta = 2.0*pow(pow(eta, 2) + 1, 4.0/3.0)*cos(theta);

         double dfzeta_dtheta = -2.0*pow(pow(eta, 2) + 1, 4.0/3.0)*sin(theta);

         double dfzeta_deta = 5.333333333333333*eta*cbrt(pow(eta, 2) + 1)*cos(theta);

         dfzeta_dpi = deta_dpi*dfzeta_deta + dfzeta_dtheta*dtheta_dpi;

         dfzeta_drho = deta_drho*dfzeta_deta + dfzeta_dtheta*dtheta_drho;

      }
      double lyp_t3 = -1.0/2.0*fzeta*lyp_cf*(1 - zeta2);

      double dlyp_t3_dzeta2 = (1.0/2.0)*fzeta*lyp_cf;

      double dlyp_t3_dfzeta = -1.0/2.0*lyp_cf*(1 - zeta2);

      double dlyp_t3_dpi = dfzeta_dpi*dlyp_t3_dfzeta + dlyp_t3_dzeta2*dzeta2_dpi;

      double dlyp_t3_drho = dfzeta_drho*dlyp_t3_dfzeta + dlyp_t3_dzeta2*dzeta2_drho;

      double xt = pow(density, -1.3333333333333333)*sqrt(sig);

      double dxt_dsig = (1.0/2.0)*pow(density, -1.3333333333333333)/sqrt(sig);

      double dxt_drho = -1.3333333333333333*pow(density, -2.333333333333333)*sqrt(sig);

      double lyp_t4 = 2*pow(2, 2.0/3.0)*lyp_aux4*pow(xt, 2)*(1 - zeta2)*(5.0/2.0 - 1.0/18.0*lyp_delta)*(zeta2 + 1);

      double dlyp_t4_dxt = 4*pow(2, 2.0/3.0)*lyp_aux4*xt*(1 - zeta2)*(5.0/2.0 - 1.0/18.0*lyp_delta)*(zeta2 + 1);

      double dlyp_t4_dzeta2 = 2*pow(2, 2.0/3.0)*lyp_aux4*pow(xt, 2)*(1 - zeta2)*(5.0/2.0 - 1.0/18.0*lyp_delta) - 2*pow(2, 2.0/3.0)*lyp_aux4*pow(xt, 2)*(5.0/2.0 - 1.0/18.0*lyp_delta)*(zeta2 + 1);

      double dlyp_t4_dpi = dlyp_t4_dzeta2*dzeta2_dpi;

      double dlyp_t4_dsig = dlyp_t4_dxt*dxt_dsig;

      double dlyp_t4_drho = -1.0/9.0*pow(2, 2.0/3.0)*dlyp_delta_drho*lyp_aux4*pow(xt, 2)*(1 - zeta2)*(zeta2 + 1) + dlyp_t4_dxt*dxt_drho + dlyp_t4_dzeta2*dzeta2_drho;

      double lyp_t5 = 2*pow(2, 2.0/3.0)*lyp_aux5*pow(xt, 2)*(1 - zeta2)*(lyp_delta - 11)*(3*zeta2 + 1);

      double dlyp_t5_dxt = 4*pow(2, 2.0/3.0)*lyp_aux5*xt*(1 - zeta2)*(lyp_delta - 11)*(3*zeta2 + 1);

      double dlyp_t5_dzeta2 = 6*pow(2, 2.0/3.0)*lyp_aux5*pow(xt, 2)*(1 - zeta2)*(lyp_delta - 11) - 2*pow(2, 2.0/3.0)*lyp_aux5*pow(xt, 2)*(lyp_delta - 11)*(3*zeta2 + 1);

      double dlyp_t5_dpi = dlyp_t5_dzeta2*dzeta2_dpi;

      double dlyp_t5_dsig = dlyp_t5_dxt*dxt_dsig;

      double dlyp_t5_drho = 2*pow(2, 2.0/3.0)*dlyp_delta_drho*lyp_aux5*pow(xt, 2)*(1 - zeta2)*(3*zeta2 + 1) + dlyp_t5_dxt*dxt_drho + dlyp_t5_dzeta2*dzeta2_drho;

      double lyp_t6 = -2*pow(2, 2.0/3.0)*lyp_aux6*xt2*((2.0/3.0)*zeta2 - 1.0/4.0*pow(1 - zeta2, 2) + 2.0/3.0);

      double dlyp_t6_dzeta2 = -2*pow(2, 2.0/3.0)*lyp_aux6*xt2*(7.0/6.0 - 1.0/2.0*zeta2);

      double dlyp_t6_dxt2 = -2*pow(2, 2.0/3.0)*lyp_aux6*((2.0/3.0)*zeta2 - 1.0/4.0*pow(1 - zeta2, 2) + 2.0/3.0);

      double dlyp_t6_dpi = dlyp_t6_dzeta2*dzeta2_dpi;

      double dlyp_t6_dsig = dlyp_t6_dxt2*dxt2_dsig;

      double dlyp_t6_drho = dlyp_t6_dxt2*dxt2_drho + dlyp_t6_dzeta2*dzeta2_drho;

      exc[g] =  lyp_a*(lyp_omega*(lyp_t2 + lyp_t3 + lyp_t4 + lyp_t5 + lyp_t6) + lyp_t1);

      double dExc_dlyp_t4 = density*lyp_a*lyp_omega;

      double dExc_dlyp_t5 = density*lyp_a*lyp_omega;

      double dExc_dlyp_t2 = density*lyp_a*lyp_omega;

      double dExc_dlyp_t1 = density*lyp_a;

      double dExc_dlyp_t6 = density*lyp_a*lyp_omega;

      double dExc_dlyp_t3 = density*lyp_a*lyp_omega;

      vrho[2 * g + 1] =  dExc_dlyp_t1*dlyp_t1_dpi + dExc_dlyp_t2*dlyp_t2_dpi + dExc_dlyp_t3*dlyp_t3_dpi + dExc_dlyp_t4*dlyp_t4_dpi + dExc_dlyp_t5*dlyp_t5_dpi + dExc_dlyp_t6*dlyp_t6_dpi;

      vsigma[3 * g + 0] =  dExc_dlyp_t2*dlyp_t2_dsig + dExc_dlyp_t4*dlyp_t4_dsig + dExc_dlyp_t5*dlyp_t5_dsig + dExc_dlyp_t6*dlyp_t6_dsig;

      vrho[2 * g + 0] =  dExc_dlyp_t1*dlyp_t1_drho + dExc_dlyp_t2*dlyp_t2_drho + dExc_dlyp_t3*dlyp_t3_drho + dExc_dlyp_t4*dlyp_t4_drho + dExc_dlyp_t5*dlyp_t5_drho + dExc_dlyp_t6*dlyp_t6_drho + density*dlyp_omega_drho*lyp_a*(lyp_t2 + lyp_t3 + lyp_t4 + lyp_t5 + lyp_t6) + lyp_a*(lyp_omega*(lyp_t2 + lyp_t3 + lyp_t4 + lyp_t5 + lyp_t6) + lyp_t1);

      //Currently, no explicit dependence
      vsigma[3 * g + 1] = 0.0;
      vsigma[3 * g + 2] = 0.0;

   }
}

}  // namespace pdftlyp
